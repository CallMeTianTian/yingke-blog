演示视频地址: https://www.bilibili.com/video/BV1nh41177Rv/

项目源代码地址: https://gitee.com/tiantian17/yingke-blog (有不好的地方 请多多指正)

# 应科博客项目报告


## 项目目的及其意义

### 1.提升写作能力

  我们计算机作为工科专业中的王牌，自然大家的写作能力也很是一般的。不过，写作能力在以后的工作中是很重要。这是已工作的朋友告知的，在以后的工作中，我们需要写汇报，各种报告以及设计文档等等，这些看似不重要的东西，确实是抓住上级的关键点，关乎你以后的晋升。而平时，我们在这方面的练习几乎又是没有的，所以说写博客，是提升学生写作能力的一个绝佳的途径。而在应科博客中你可以自由发挥，Dambisa Moyo曾说过:"种一棵树最好的时间是十年前，其次是现在"，如果你还不会写博客，还不会markdown语法。那么来应科博客就对了，网站支持图文展示，支持markdown所有语法，markdown语法在线学习。

<img src=".\image\04.写作markdown实时预览.png" style="zoom: 80%;" />

### 2.总结错误

  没有bug的人生是不完美的人生。我们在码代码的过程中，难免会遇到很多的问题，通过我们努力了很久解决的问题，如果不做记录的话，可能下次遇到的时候，你还是一脸懵逼（深有体会），所以总结你平时遇到的问题也是写博客的一个很不错的方向，这样的话，你可以在下次遇到同样问题时候，可以很快解决。当然了，还可以帮助他人解决同样的问题。何乐而不为呢？

### 3.记录学习

  作为学生，要想变成一个技术大佬，自然是需要不断学习，那这就成为了一个非常不错的写作素材。在我们进行系统学习的过程中，我们可以把我们学习的内容，分成不同的点，然后总结一下，发布到应科博客中。一方面有助于后面自己的复习，另外一方面可以给他人的学习提供一个很好的参考。

<img src=".\image\02.记录学习.png" style="zoom:80%;" />

### 4.为简历加分

  毕竟我们最终还是要走向工作的，这免不了的就是我们的简历，如果我们能够在简历上写上我们的博客链接，这将会是一个非常好的展示我们自己的机会。毕竟面试的时间是有限的，面试官总有些东西是问不到的，那么他就会去看一下你的博客链接，了解下你的学习经历，看看你学过哪些知识（已工作的人告诉我的）。

### 5.帮助他人

  计算机追求的是开源，是分享。在我们学生时代，开源的项目能做出来的应该是极少数，那我们也可以通过分享的形式来帮助他人，毕竟总有人在路上，我们走过的路都能成为别人避免弯路，学习的途径。应科博客面向广应科计算机学院师生，在计算机学院中，我们的人才培养方案大同小异，教学内容基本一致，而遇到的问题也不会相差太多，在应科博客中就具有很强的针对性，我们可以将自己的报错解决方案提交到应科博客中，供广大计院学生参考。

### 6.分享生活趣事，扩展人脉

  古话说得好：一个人走的更快，但一群人走的更远！这句话放在我们学生阶段是再合适不过了，此时的我们未经世事，资历尚浅，如果能有前辈能给我们指点一二，那我们会避免很多的弯路。同时应科博客不止有学习，我们也可以分享一些生活趣事。据我所知，广应科还没有属于自己的论坛，学生相互认识只能通过学校活动和社团或协会活动，毕竟参加人数有限制，而在应科博客中我们可以通过评论和关注来结交广大朋友。学生可点击用户头像跳转到用户个人信息，且学生可自由填写个人信息，可到线下认识或深入交流学习。

<img src=".\image\01.鼎湖山一日游评论展示.png" style="zoom:80%;" />

### 7.提升做题能力

  想要巩固基础，查漏补缺，刷题肯定是你最好的选择，在应科博客中提供了每日刷题功能，题目不多不少，难度适中，能让同学们保持学习状态。在刷题过后，应科博客提供完整的答案解析，能让同学我们认识到自己的不足，加以改正。且我们在找工作的时候肯定离不开笔试，在每日刷题中，我们能形成自己的解题节奏，在笔试中脱颖而出。

<img src=".\image\42.编程题模块.png" style="zoom:65%;" />



# 项目介绍

> **应科博客** 是一个由JavaEE开发的博客系统，基于经典主流技术组合（SpringBoot、Sa-token、MyBatis、Jwt、Vue），内置模块如下:
>
> 登录注册、每日刷题、书写文章、博客管理、动态博客分类、博客发布、用户评论、权限校验、个人信息管理、定时任务、视频播放等。

## 一.项目架构

### 1.技术栈介绍

#### (1)后端

1. SpringBoot2: 后端服务开发框架
2. MyBatis: 数据库交互与管理
3. MySQL: 关系型数据库存储数据
4. Druid: 数据库连接池
5. Redis: 数据缓存和业务逻辑实现
6. Sa-token: 身份与权限管理(最新国产开源安全框架)
7. JWT: 前后端分离令牌
9. AES: 对称加密算法
10. PageHelper: 数据分页查询
11. Boot-mail: 发送QQ邮件
12. Hutool: Java工具包
13. OSS: 阿里云OSS存储
14. Lombok: 自动插入编辑器并构建工具
15. Jackson: JavaJSON解析器

#### (2)前端

1. Vue2: 前端服务开发框架
2. VueX: 数据持久化
3. VueRouter: 路由
4. Axios: 异步通信
5. Element-ui+Bootstrap: 前端样式/组件
6. 其他第三方插件: 
   1. mavon-editor(构建markdown编辑器)
   2. marked(markdown转html)
   3. highlight.js(代码高亮)
   4. nprogress(进度条)
   5. animate.css(动画库)
   6. vue-aplayer(视频播放器)
   7. echarts(数据可视化框架)
   8. codemirror(带提示功能的代码编辑器)

### 2.运行环境

开发工具:

1. IDEA2022.3.1(后端)
2. WebStorm2022.3.1(前端)
3. Navicat16(操作MySQL)
4. RESP(操作Redis)


服务开发版本:

1. SpringBoot 2.7.9
1. 其他相关依赖版本如图:

<img src=".\image\03.后端依赖.png" style="zoom:80%;" />

3. Maven 3.8.1
4. Vue 2.6.14
5. Node 16.18.1
6. mysql 8.30
7. Redis 7.0



### 3.架构设计与分析

整个项目采用主流的前后端分离项目架构，后端使用SpringBoot开发，前端使用Vue开发。项目的用例设计思路如下：

> 基本用例：博客列表展示、博客详情展示、博客搜索、博客分类列表展示、友链展示、关于我展示、登陆/注册、展示/修改个人信息、我的博客列表管理、我的资源列表管理、他人空间展示（信息、博客、学习记录）、博客留言模块、博客编辑/发表、学习情况编辑/发表、退出/注销。
> 权限等级：admin>teacher>user
> admin：拥有博客系统的所有权限，可以登陆后台管理系统，admin权限不存在注册渠道。
> teacher：拥有上传题目、题目修改、题目评分、博客浏览、资源浏览、博客发布、评论权限
> user：拥有博客浏览、资源浏览、博客发布、资源发布、资源浏览、评论权限，用户在注册时默认为user权限。

## 二.本地环境部署说明

### 1.下载

#### 前端代码下载

前往`Gitee`下载页面https://gitee.com/tiantian17/yingkeBlog-ui下载解压到工作目录

#### 后端代码下载

前往`Gitee`下载页面https://gitee.com/tiantian17/yingkeBlog下载解压到工作目录

### 2.修改必要配置

2.1.数据源配置

```yml
 spring:
  datasource:
    type: com.alibaba.druid.pool.DruidDataSource
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: 数据库地址
    username: 数据库账号
    password: 数据库密码
```

2.2.Redis配置

```yml
  redis:
    host: Redis的地址
    port: Redis的端口
    # password: 有设置密码就写
    database: 0 # 默认使用0号数据库 共16个
    timeout: 10s
    lettuce:
      pool:
        # 连接池最大连接数
        max-active: 200
        # 连接池最大阻塞等待时间（使用负值表示没有限制）
        max-wait: -1ms
        # 连接池中的最大空闲连接
        max-idle: 10
        # 连接池中的最小空闲连接
        min-idle: 0
  cache:
    redis:
      time-to-live: 180000 # 毫秒  如果不设置就是永久缓存
```

2.3.邮件配置 => 主要发送验证码邮件(若没有可以直接用我的账号和密码, 按照`3.13`中申请即可)

```yml
  mail:
    host: smtp.qq.com
    username: 你的邮箱账号   # 1979214069@qq.com
    password: 你申请到的密钥 #  xmxalekbbfmvihiD
    default-encoding: utf-8
    properties:
      mail:
        smtp:
          auth: true
          starttls:
            enable: true
            required: true
```

2.4.其他非必要配置

```yml
sa-token:
  # token名称 (同时也是cookie名称)
  token-name: TTtoken
  # token有效期，单位s 默认30天, -1代表永不过期
  timeout: 2592000 # 30天
  # token临时有效期 (指定时间内无操作就视为token过期) 单位: 秒
  activity-timeout: -1
  # 是否允许同一账号并发登录 (为true时允许一起登录, 为false时新登录挤掉旧登录)
  is-concurrent: true
  # 在多人登录同一账号时，是否共用一个token (为true时所有登录共用一个token, 为false时每次登录新建一个token)
  is-share: true
  # token风格
  token-style: jwt
  # 是否输出操作日志
  is-log: true
  # jwt秘钥
  jwt-secret-key: SGSIDNgdsgisdgdfinnnsdfsd

tiantianstudy:
  # 本地图片的保存的地址 => 默认为 D:/imgs/ (会自动创建)
  path: D:/imgs/
  # 用登录注册时ASE加密算法的key 解密时用的也是这个
  password-key: HovJ2n2sqkNXEio6Ji0QQJAFLW1Kt80qypMqot+mHhS+0KfdOpaKeMWMSR4Ij5VfE63WzETEeWAMQESxzhavN1WOTb3/p6icgcVbgPQBaWhGg==
```

### 3.后端运行

1、导入到`idea`，菜单 `File` -> `Import`，然后选择 `Maven` -> `Existing Maven Projects`，点击 `Next`> 按钮，选择工作目录，然后点击 `Finish` 按钮，即可成功导入。`idea`会自动加载`Maven`依赖包  详细:https://blog.csdn.net/Golovin/article/details/100156311
2、创建数据库`yingkeblog`并执行脚本`yingkeBlog.sql`生成对应的结构和数据
3、打开项目运行`com.tiantian.TiantTianStudyApplication.java`，出现如下图表示启动成功。

<img src=".\image\50.启动成功.png" style="zoom:70%;" />

### 4.前端运行

```bash
# 1.进入项目目录
cd yingkeBlog-ui

# 2.安装依赖
npm install

# 3.启动项目
npm run server
```



4、打开浏览器，输入：http://localhost:80  默认账户/密码 `1979214069@qq.com/123456`）
若能正确展示登录页面，并能成功登录，菜单及页面展示正常，则表明环境搭建成功



## 三.文件结构

### 3.1.后端结构

```tex
├─tiantianstudy-admin			 			// 后台管理: 主要负责题目评分,博客,评论和个人信息的审核(但目前还在制作中)
│  └─src
│      ├─main
│      │  ├─java
│      │  │  └─com
│      │  │      └─tiantian
│      │  └─resources
│      └─test
│          └─java
└─tiantianstudy-common						// 核心模块
    ├─src
    │  ├─main
    │  │  ├─java
    │  │  │  └─com
    │  │  │      └─tiantian
    │  │  │          ├─config				// 全局配置
    │  │  │          ├─constants			// 常用常量
    │  │  │          ├─controller			// 接口层: 用户访问请求时对接
    │  │  │          │  └─visualization     // 数据可视化相关接口
    │  │  │          ├─dto					// 数据传输对象: 前端要什么就给什么
    │  │  │          ├─exception			// 全局异常处理器
    │  │  │          ├─handler				// 处理器映射器
    │  │  │          ├─mapper				// dao层接口
    │  │  │          ├─pojo					// 实体类: 用于封装数据返回接口层
    │  │  │          ├─service				// 业务层接口
    │  │  │          │  └─impl				// 业务层实现类: 处理复杂业务(若业务简单可直接省略这层)
    │  │  │          ├─task					// 定时任务
    │  │  │          └─utils				// 常用工具类的封装
    │  │  │              └─vo				// 多表查询时封装的数据
    │  │  └─resources
    │  │      └─mapper						// sql映射文件
```

### 3.2.前端结构

```tex
├── public                     // 公共文件
│   ├── favicon.ico            // favicon图标
│   └── index.html             // html模板
├── src                        // 源代码
│   ├── api                    // 所有请求
│   ├── assets                 // 主题 字体等静态资源
│   ├── components             // 全局公用组件
│   ├── plugins                // 插件
│   ├── mook 				   // 使用json-server模拟的数据(可删)
│   ├── router                 // 路由
│   ├── store                  // 全局store管理
│   ├── utils                  // 全局公用方法
│   ├── pages                  // view
│   ├── App.vue                // 入口页面
│   ├── main.js                // 入口 加载组件 初始化等
```



# 详细设计

## 1.前端设计

> 字体: 使用华为鸿蒙开源的`HarmonyOS Sans字体`
>
> logo: 使用了[DesignEvo](https://www.designevo.com/cn/logo-maker/)在线设计
>
> 图标及其插画: 使用了阿里巴巴矢量图标库`iconfont`
>
> 组件库: 大量使用了饿了吗团队开发的`Element UI组件库`以此达到快速开发的目的
>
> 样式框架: 使用Twitter开源的`bootstrap5`
>

### 整体页面设计

配色如下

<img src=".\image\32.整体色调.png" style="zoom:80%;" />

从左到右: #ecf5ff #88b8ff #0d6efd #ebeced #d3d3d4 #d1e7dd #cfe2ff #ffffff #f0f9eb #f4f4f5



### 1.1.对axios的二次封装

```java
import axios from 'axios'
import NProgress from 'nprogress';
import 'nprogress/nprogress.css';
import {Message} from 'element-ui'

const instance = axios.create({
 // 请求基本地址
 baseURL: 'http://localhost',
 // 超时时间
 timeout: 4000,
})

// 请求拦截器
instance.interceptors.request.use((config) => {
 // 发送请求进度条开始
 NProgress.start()
 const token = localStorage.getItem("TTtoken")
 // 每次发送请求时 都带上TTtoken这个请求头给后端进行认证和解析jwt获取数据
 token ? config.headers["TTtoken"] = token : null;

 return config;
}, function (error) {
 Message.error("请求错误")
 return Promise.reject(error);
});

// 响应拦截器
instance.interceptors.response.use((response) => {
 // 响应后进度条结束
 NProgress.done();
 
 return response;
}, function (error) {
 Message.error("响应错误")
 return Promise.reject(error);
});


export default instance
```

在api的封装 部分api展示`api/blogApi.js`

```js
export function deleteBlogByLoginUser(blogId) {
 return request({
  method: 'delete',
  url: `/blog/delete/${blogId}`
 })
}

export function getBlogLabelCount() {
 return request({
  method: 'GET',
  url: '/count/label'
 })
}
```

### 1.2.路由配置

1.总览

<img src=".\image\24.路由总览.png" style="zoom:80%;" />

2.部分路由配置

在路由元信息中配置title用于给document.title赋值 提高用户体验感

在路由元信息中配置requireAuth表示需要权限才能跳转到这个路由

```js
{
 path: '/user-space',
 name: 'user-space',
 component: () => import('@/pages/person/space/UserSpace.vue'),
 redirect: '/user-space/space-info',
 meta: {title: '应科博客 | 个人中心', requireAuth: true}, //是否需要登录才能访问: true
 children: [
  {
   path: "/user-space/space-info",
   name: "space-info",
   component: () => import('@/pages/person/UserInfo/SpaceInfo.vue'),
   meta: {title: '应科博客 | 个人中心', requireAuth: true}
  },
  {
   path: '/user-space/changepwd',
   name: 'changepwd',
   component: () => import('@/pages/person/ChangePassword/ChangePwd.vue'),
   meta: {title: '应科博客 | 个人中心', requireAuth: true}
  },
  {
   path: '/user-space/my-follow',
   name: 'my-follow',
   component: () => import('@/pages/person/UserInfo/MyFollow.vue'),
   meta: {title: '应科博客 | 我的关注', requireAuth: true}
  },
  {
   path: '/user-space/my-collect',
   name: 'my-collect',
   component: () => import('@/pages/person/UserInfo/MyCollect.vue'),
   meta: {title: '应科博客 | 我的收藏', requireAuth: true}
  },
  {
   path: "/user-space/blog-list",
   name: "blog-list",
   component: () => import("@/pages/person/UserInfo/BlogList.vue"),
   meta: {title: '应科博客 | 博客管理', requireAuth: true}
  },
  {
   path: '/user-space/study-chart',
   name: 'study-chart',
   component: () => import('@/pages/DataVisualizationCenter/StudyChart.vue'),
   meta: {title: '应科博客 | 学习可视化', requireAuth: true}
  },
  {
   path: '/user-space/blog-chart',
   name: 'blog-chart',
   component: () => import('@/pages/DataVisualizationCenter/BlogChart.vue'),
   meta: {title: '应科博客 | 博客可视化中心', requireAuth: true}
  }
 ]
},
```

3.路由守卫相关配置

```js
import { Message } from 'element-ui';

// 前置路由守卫
router.beforeEach((to, from, next) => {
	NProgress.start()
	// 判断页面是否为需要登录才能访问的页面
	if (to.meta.requireAuth) {
		//判断token是否存在
		if (localStorage.getItem("TTtoken") !== null) {
			// 存在直接放行
			next();
		} else {
			// 不存在跳转到登录页面
			Message.warning("无权操作 请先登录 !")
			next({path: '/login'});
		}
	} else {
		next();
	}
})


// 后置路由守卫 => 路由切换之后被调用
router.afterEach((to) => {
 NProgress.done()
 // 修改标签页标题信息
 document.title = to.meta.title || "应科博客"
})
```

当未登录时 直接访问用户个人信息界面(requireAuth为true时)

<img src=".\image\51.未登录访问用户个人信息界面.png" style="zoom:70%;" />



会自动跳转的登录页面

<img src=".\image\52.跳转登录页面.png" style="zoom:75%;" />

### 插件集成

#### 1.mavon-editor

> 一款基于vue的markdown编辑器, [详细配置教程](https://blog.csdn.net/ws6afa88/article/details/108765569), 支持markdown所有语法, 内置快捷键, 图片上传, 实时预览等功能 简单易用快速上手

mavon-editor整体样式和功能列表如图

<img src=".\image\04.写作markdown实时预览.png" style="zoom:80%;" />

前面说到在应科博客中, 能学习到markdown的语法, 这个功能就是由mavon-editor提供的, 在mavon-editor左上角提供了markdown语法帮助

按钮, 当忘记的时候, 可以点击按钮查看文档, 相信实践过几次你就能精通啦!

<img src=".\image\10.markdown编辑器语法教学.png" style="zoom:80%;" />

`editor组件(可直接复用)`

```vue
<mavon-editor
  v-model="article.context"
  ref="md"
  @change="change"
  class="my-editor"
/>

<script>
import {mavonEditor} from 'mavon-editor';
export default {
  name: 'Editor',
  // 注册组件
  components: {
    mavonEditor,
  },
  // 数据模型
  data() {
    return {
      article: {
        title: '', // 文章的标题
        label: '', // 文章的标签
        context: '# :one:请开始你的创造:smiley:', // 默认内容
        html: ''   // 实时转化的html内容
      },
    }
  },
  
  methods: {
    // 所有操作都会被解析重新渲染
    change(value, render) {        //value为编辑器中的实际内容，即markdown的内容，render为被解析成的html的内容
      this.article.html = render;
    },
    
    // 提交
    submit() {                     //点击提交后既可以获取html内容，又可以获得markdown的内容，之后存入到数据库就可以了
      if (this.article.title === '') {
        this.$notify({
          title: '警告',
          message: '文章标题不能为空',
          type: 'warning'
        });
        return
      }
      if (this.article.label === '') {
        this.$notify({
          title: '警告',
          message: '文章标签不能为空',
          type: 'warning'
        });
        return;
      }
      // blogApi中的addBlog
      addBlog(this.article).then((res) => {
        if (res.data.code === 200) {
          this.$notify({
            title: '成功',
            message: '文章提交成功 ! 请等待审核',
            type: 'success'
          });
          // 刷新当前页面
          setTimeout(() => {
            location.reload();
          }, 500)
        } else {
          this.$notify({
            title: '失败',
            message: '文章提交成功',
            type: 'error'
          });
        }
      })
    },
  },
}
</script>
<style scoped lang="css">
    .my-editor {
        min-height: 530px;
        max-height: 800px;
        width: 100%;
        margin: 5px auto
    }
</style>
```



#### 2.marked

> 当用到markdown的时候, 肯定离不开markdown与html的相互转化, 应科博客中就是从数据库中读取到markdown语法的博客, 再使用marked转化成html展示给用户, 那为什么不直接存html呢? 因为html太长了, 一堆标签和样式非常的占用内存

仅需几行代码即可实现

```js
import {marked} from "marked";
// 将markdown转化为html展示渲染到页面中
markdownChangeHtml() {
  this.codeDataHtml = marked(this.codeDataMarkDown)
},
```

#### 3.nprogress

> 进度条: 主要由于发送请求和切换路由时使用
>
> nprogress: "当用户看着进度条的时候，滚动的光束会吸引你的注意力，它改变了等待的体验，把它变成了一件让你兴奋的新鲜事。"

如图, 仅需四行代码即可实现

<img src=".\image\26.进度条展示.png" style="zoom:80%;" />

```js
// 引入js代码和样式
import NProgress from 'nprogress';
import 'nprogress/nprogress.css'; // 可自定义进度条的颜色 应科博客中用的是 '#29d'
// 进度条开始
NProgress.start();
// 进度条结束
NProgress.done();
```

#### 4.codemirror

> 一款强大的代码编辑器,有高达64款的样式,最强大的是, 他有很好的代码提示且基本支持广应科学生学过的所有编程语言

<figure><img src=".\image\21.代码编辑器.png" style="zoom: 80%;" /><img src=".\image\25.代码编辑器样式选择.png" style="zoom: 80%;" /></figure>



`IDE组件(可直接复用)`

```vue
<template>
  <div>
    <codemirror ref="myCm" :value="code" v-model="code" :options="cmOptions" @change="codeChange" @ready="onReady">
    </codemirror>
    
    <el-select v-model="cmOptions.theme"
               placeholder="切换主题"
               @change="setTheme"
               style="float: right;margin-top: 5px">
          <span slot="prefix">
             <el-tooltip content="更换主题">
      </el-tooltip>
      </span>
      <el-option v-for="(item,index) in supportThemes" :key="index" :label="item" :value="item">
      </el-option>
    </el-select>
    
    <button class="btn btn-secondary" style="float: right;margin-right: 20px;margin-top: 5px">
      开启代码提示功能
      <el-switch
        style="margin-bottom: 3px;"
        v-model="value"
        active-color="#409eff"
        inactive-color="#dcdfe6">
      </el-switch>
    </button>
  </div>
</template>

<script>
// 引入组件
import {codemirror} from "vue-codemirror";
// 全局css => 只可以在这里调整宽高
import 'codemirror/lib/codemirror.css'
// 引入主题(共65种,这里引入了一些我觉得好看的) 引入之后在supportThemes数组添加对应的主题即可
import 'codemirror/theme/base16-dark.css'
import 'codemirror/mode/sql/sql'
import 'codemirror/mode/clike/clike.js'
import "codemirror/theme/eclipse.css";
import "codemirror/theme/blackboard.css";
import "codemirror/theme/cobalt.css";
import "codemirror/theme/ayu-mirage.css";
import "codemirror/theme/juejin.css";
import "codemirror/theme/duotone-light.css";
import "codemirror/theme/mdn-like.css";
import "codemirror/theme/paraiso-light.css";
import "codemirror/theme/idea.css";
import "codemirror/theme/material-darker.css";
//光标行背景高亮，配置里面也需要styleActiveLine设置为true
import 'codemirror/addon/selection/active-line';

// 引入自动补全代码的功能
import "codemirror/addon/lint/lint.css";
import "codemirror/addon/lint/lint.js";
import "codemirror/addon/display/autorefresh";
import 'codemirror/addon/edit/closebrackets.js'
import 'codemirror/addon/hint/show-hint.js';
import 'codemirror/addon/hint/show-hint.css';
import 'codemirror/addon/hint/sql-hint';
import "codemirror/addon/edit/closebrackets.js";
import "codemirror/addon/edit/closetag.js";
import "codemirror/addon/edit/matchtags.js";
import "codemirror/addon/edit/matchbrackets.js";
import 'codemirror/addon/hint/javascript-hint';
import 'codemirror/addon/hint/html-hint';

// 代码折叠功能
import 'codemirror/addon/fold/foldgutter.css'
import 'codemirror/addon/fold/foldcode'
import 'codemirror/addon/fold/foldgutter'
import 'codemirror/addon/fold/brace-fold'
import 'codemirror/addon/fold/comment-fold'
import 'codemirror/addon/fold/markdown-fold'
import 'codemirror/addon/fold/xml-fold'
import 'codemirror/addon/fold/indent-fold'
import 'codemirror/addon/search/match-highlighter'

export default {
  name: "IDE",
  // 父组件传递的代码模式 支持 sql java(text/x-java) js html css python 等代码提示
  props: ['codeMode'],
  data() {
    return {
      // 默认有个main方法
      code: `public static void main(String args[]){
  
}`,
      value: true,  // 是否开启代码提示 默认开启
      cmOptions: {
        mode: this.codeMode || 'text/x-java', // 代码模式 默认为Java
        theme: "mdn-like",  // 设置主题 默认为 mdn-like
        autofocus: true,    // 自动获取焦点
        autocorrect: true,  // 自动更正
        spellcheck: true,  // 拼写检查
        lint: true,  // 检查格式
        tabSize: 4, // 制表符
        indentUnit: 2, // 缩进位数
        lineNumbers: true, // 显示行号
        smartIndent: true, // 智能缩进
        autoCloseBrackets: true, // 自动关闭括号
        matchBrackets: true, // 自动突出显示匹配的括号
        styleActiveLine: true,//line选择是是否加亮
        // 开启代码折叠
        gutters: [
          "CodeMirror-lint-markers",
          "CodeMirror-linenumbers",
          "CodeMirror-foldgutter"
        ],
        foldGutter: true, // 启用行槽中的代码折叠
        highlightSelectionMatches: {
          minChars: 2,
          trim: true,
          style: "matchhighlight",
          showToken: false
        },
      },
      // 支持的主题
      supportThemes: ['eclipse', 'idea', 'material-darker', 'blackboard', 'mdn-like', 'paraiso-light', 'base16-dark', 'cobalt', 'ayu-mirage', 'juejin', 'duotone-light'],
    }
  },
  // 组件实例化完毕 从localStorage获取用户设置的主题并设置
  created() {
    let theme = localStorage.getItem("TTtheme");
    // 若没有设置主题则使用默认的
    if (theme !== null) {
      this.cmOptions.theme = theme
    }
  },
  methods: {
    onReady(cm) {
      // 判断用户是否开启代码提示功能
      if (!this.value) {
        cm.on('keypress', () => {
          cm.showHint({completeSingle: false})
        })
      }
    },
    // 将输入的代码传递给父组件
    codeChange() {
      this.$emit("getCodeAnswer", this.code);
    },
    // 将设置的主题保存到localStorage
    setTheme(val) {
      localStorage.setItem("TTtheme", val)
    }
  },
  components: {
    codemirror,
  }
  
}
</script>
```



#### 5.highlight.js

> 实现代码高亮, 支持多种风格, 这里主要使用的是github风格的代码高亮效果

<img src=".\image\22.代码高亮1.png" style="zoom:80%;" />

<img src=".\image\23.代码高亮2.png" style="zoom:80%;" />GitHub风格的代码高亮

#### 6.vue-core-video-player

> vue视频播放器 样式好看

整体样式

![](.\image\11.视频播放器整体样式.png)

支持在最前端窗口播放

![](.\image\12.支持窗口播放.png)

`video组件(可直接复用)`  详细配置:https://www.cnblogs.com/My-IronMan/p/16209251.html

```vue
<template>
  <div>
    <vue-core-video-player :src="videoSource" :cover="cover" :title="title" loop="false"/>
  </div>
</template>

<script>
export default {
  name: "myVideo",
  data() {
    return {
      videoSource: [{
        // 视频播放的地址
        src: 'https://media.vued.vanthink.cn/y2mate.com%20-%20sparkle_your_name_amv_K_7To_y9IAM_1080p.mp4',
        // 默认1080p播放
        resolution: 1080
      }],
      // 封面的图片
      cover: "https://img1.wxzxzj.com/vpc-example-cover-your-name-c.png",
      // 封面的标题
      title: "你的名字"
    }
  },
}
</script>
```

## 2.后端设计

### 2.1.数据库设计

#### 1.用户管理模块

<img src=".\image\06.用户数据库设计.png" style="zoom:80%;" />

#### 2.博客模块

<img src=".\image\05.数据库设计.png" style="zoom:80%;" />

#### 3.课程学习模块

<img src=".\image\06.1数据设计之课程.png" style="zoom:80%;" />

#### 4.每日刷题模块

<img src=".\image\31.题库数据库的设计.png" style="zoom:80%;" />

### 2.2.统一接口规范

> 统一返回的json数据的格式,并规定状态码200代表成功,其他状态码均代表失败

```Java
@Data // 使用Lombok注解简化开发
public class Result implements Serializable {
    private Object data;
    private Integer code;
    private String message;

    public Result(Integer code, String message, Object data) {
        this.data = data;
        this.code = code;
        this.message = message;
    }
    public Result(Integer code, String message) {
        this.code = code;
        this.message = message;
    }

    public static Result ok(String msg){
        return new Result(200,msg);
    }

    public static Result ok(Object data){
        return new Result(200,"SUCCESS",data);
    }

    public static Result failure(String msg){
        return new Result(403,msg);
    }

    public static Result failure(){
        return new Result(403,"FAILURE");
    }

    public static Result ok(){
        return new Result(200,null);
    }

    // 如果更新记录数 >0 表达更新成功
    public static Result update(int count){
        String msg = count > 0 ? "SUCCESS" :"FAILURE";
        int code = count > 0 ? 200 : 500;
        return new Result(code,msg);
    }

    // 如果删除记录数 >0 表达删除成功
    public static Result delete(int count){
        String msg = count > 0 ? "SUCCESS" :"FAILURE";
        int code = count > 0 ? 200 : 500;
        return new Result(code,msg);
    }
}
```

### 2.3.遵循依赖倒转原则

面向接口开发所有业务层接口都对应着一个实现类，减少类间的耦合性，提高系统的稳定性，降低`并行开发`引起的风险，提高代码的可读性和可维护性。

<img src=".\image\07.依赖倒转原则的遵循.png" style="zoom:80%;" />

### 2.4.全局异常处理

主要处理用户未登录的异常和全局异常(服务器内部的异常), 当服务器内部出现异常时, 会给运维人员发送邮件, 确保bug能第一时间被修复

```java
@RestControllerAdvice
public class GlobalExceptionHandler {
    
    @Autowired
    private SendMailService sendMailService;
    
    // 全局异常拦截 
    @ExceptionHandler
    public SaResult handlerException(Exception e) {
        // 给运维人员发邮件通知前来修复
        MailRequest mailRequest = new MailRequest();
        mailRequest.setSubject("应科博客");
        mailRequest.setSendTo("1979214069@qq.com");
        mailRequest.setText("服务器出现异常报错信息为: " + e.getMessage() +"原因为: "+ e.getCause()  + "\n请尽快前来修复");
        mailRequest.setFrom("1979214069@qq.com" + "(应科博客Error)");
        sendMailService.sendSimpleMail(mailRequest);
        // 打印异常到控制台
        e.printStackTrace();
        System.out.println(e.getCause().toString());
        return SaResult.error("服务器异常");
    }

    // 拦截项目中的NotLoginException异常
    @ExceptionHandler(NotLoginException.class)
    public SaResult handlerNotLoginException(NotLoginException nle)
            throws Exception {

        // 打印堆栈，以供调试
        nle.printStackTrace();

        // 判断场景值，定制化异常信息
        String message;
        if (nle.getType().equals(NotLoginException.NOT_TOKEN)) {
            message = "未提供token";
        } else if (nle.getType().equals(NotLoginException.INVALID_TOKEN)) {
            message = "token无效";
        } else if (nle.getType().equals(NotLoginException.TOKEN_TIMEOUT)) {
            message = "token已过期";
        } else if (nle.getType().equals(NotLoginException.BE_REPLACED)) {
            message = "token已被顶下线";
        } else if (nle.getType().equals(NotLoginException.KICK_OUT)) {
            message = "token已被踢下线";
        } else {
            message = "当前会话未登录";
        }
        // 返回给前端
        return SaResult.error(message);
    }
}
```

### 2.5.博客动态分类

动态分类可具有拓展性, 若后续有其他编程语言和技术或全校师生的加入, 可以直接在后台管理中添加分类, 无需修改前端代码, 完全无侵入式

<img src=".\image\08.高拓展性.png" style="zoom:80%;" />

### 2.6.整合Redis

1.Redis工具类的封装

```java
@Component
public class CacheClient {

    @Autowired
    private StringRedisTemplate stringRedisTemplate;

    /**
     * 设置Redis缓存
     *
     * @param key   缓存的键
     * @param value 缓存的值
     * @param time  缓存过期时间
     * @param unit  缓存过期时间的单位
     */
    public void set(String key, Object value, Long time, TimeUnit unit) {
        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(value), time, unit);
    }

    public <R> R get(String key,Class<R> type){
        String str = stringRedisTemplate.opsForValue().get(key);
        return JSONUtil.toBean(str, type);
    }

    public Boolean delete(String key){
        return stringRedisTemplate.delete(key);
    }


    public void setWithLogicalExpire(String key, Object value, Long time, TimeUnit unit) {
        // 设置逻辑过期
        RedisData redisData = new RedisData();
        redisData.setData(value);
        redisData.setExpireTime(LocalDateTime.now().plusSeconds(unit.toSeconds(time)));
        // 写入Redis
        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(redisData));
    }

    /**
     * 防止缓存击穿
     *
     * @param keyPrefix  key的前缀
     * @param id         key的id
     * @param type       类型 xxx.Class
     * @param dbFallback 查询数据库的函数
     * @param time       过期时间
     * @param unit       过期时间的单位
     * @param <R>
     * @param <ID>
     * @return
     */
    public <R, ID> R queryWithPassThrough(
            String keyPrefix, ID id, Class<R> type, Function<ID, R> dbFallback, Long time, TimeUnit unit) {
        String key = keyPrefix + id;
        // 1.从redis查询缓存
        String json = stringRedisTemplate.opsForValue().get(key);
        // 2.判断是否存在
        if (StrUtil.isNotBlank(json)) {
            // 3.存在，直接返回
            return JSONUtil.toBean(json, type);
        }
        // 判断命中的是否是空值
        if (json != null) {
            // 返回一个错误信息
            return null;
        }
        // 4.不存在，根据id查询数据库
        R r = dbFallback.apply(id);
        // 5.不存在，返回错误
        if (r == null) {
            // 将空值写入redis
            stringRedisTemplate.opsForValue().set(key, "", 2, TimeUnit.MINUTES);
            // 返回错误信息
            return null;
        }
        // 6.存在写入redis
        this.set(key, r, time, unit);
        return r;
    }

    private static final ExecutorService CACHE_REBUILD_EXECUTOR = Executors.newFixedThreadPool(10);

    public <R, ID> R queryWithLogicalExpire(
            String keyPrefix, ID id, Class<R> type, Function<ID, R> dbFallback, Long time, TimeUnit unit) {
        String key = keyPrefix + id;
        // 1.从redis查缓存
        String json = stringRedisTemplate.opsForValue().get(key);
        // 2.判断是否存在
        if (StrUtil.isBlank(json)) {
            // 3.存在，缓存中存的null
            return null;
        }
        // 4.命中，先把json反序列化为对象
        RedisData redisData = JSONUtil.toBean(json, RedisData.class);
        R r = JSONUtil.toBean((JSONObject) redisData.getData(), type);
        LocalDateTime expireTime = redisData.getExpireTime();
        // 5.判断是否过期
        if (expireTime.isAfter(LocalDateTime.now())) {
            // 5.1未过期，直接返回信息
            return r;
        }
        // 5.2已过期，需要缓存重建
        // 6.缓存重建
        // 6.1获取互斥锁
        String lockKey = LOCK_SHOP_KEY + id;
        boolean isLock = tryLock(lockKey);
        // 6.2判断是否获取锁成功
        if (isLock) {
            // 6.3 成功，再进行二次判断，查看缓存中是否有数据，因为有可能是别人刚刚重建完释放锁，刚好获取到了

            // 6.4 开启独立线程，实现缓存重建
            CACHE_REBUILD_EXECUTOR.submit(() -> {
                try {
                    // 查询数据库
                    R r1 = dbFallback.apply(id);
                    // 写入redis
                    this.setWithLogicalExpire(key, r1, time, unit);
                } catch (Exception e) {
                    throw new RuntimeException(e);
                } finally {
                    // 释放锁
                    unlock(lockKey);
                }
            });
        }
        // 6.6返回过期的商铺信息
        return r;
    }

    private boolean tryLock(String key) {
        Boolean flag = stringRedisTemplate.opsForValue().setIfAbsent(key, "1", 10, TimeUnit.SECONDS);
        return BooleanUtil.isTrue(flag);
    }

    private void unlock(String key) {
        stringRedisTemplate.delete(key);
    }
}
```

2.在每日一句和每日刷题的功能中, 由于用户每次登录都会打开首页使用这两个功能, 读取频繁, 所以在这个地方可以做个缓存, 减轻数据库的压力

```java
@Autowired
private WordMapper wordMapper;

@Autowired
private CacheClient cacheClient;

@GetMapping
public Result getWords(){
    // 先查缓存是否存在数据
    Word wordCache = cacheClient.get(EVERY_DAY_WORD, Word.class);
    if (wordCache.getWord() != null) {
        return Result.ok(wordCache);
    }
    // 未命中缓存查询数据库
    Word word = wordMapper.getWordAndId();
    System.out.println(word);
    // 将查询到的数据存到Redis并设置缓存24小时过期
    cacheClient.set(EVERY_DAY_WORD,word,24L, TimeUnit.HOURS);
    return Result.ok(word);
}
```

<img src=".\image\28.句子缓存展示.png" style="zoom:80%;" />

在定时任务中, 到更新的时间后再将缓存删除, 等到用户来访问的时候再次做新的缓存, 一直循环下去

```java
@Autowired
private WordMapper wordMapper;

@Autowired
private CacheClient cacheClient;

@Scheduled(cron = "0 0 0 * * ?") // 每天0点 开始更新每日一句
public void changeWord(){
    System.err.println("开始执行静态定时任务,时间为: " + LocalDateTime.now());
    // 先获取出当前句子id  再用当前句子的id将字段获取的is_show更新为1
    Word word = wordMapper.getWordAndId();
    wordMapper.updateIsShowByIdInt(word.getId());
    // 将缓存清空
    cacheClient.delete(EVERY_DAY_WORD);
}
```

### 2.7.接口文档

> 相比与统称的接口文档, 应科博客使用了国产的[Apifox](https://apifox.com/)在线生成接口文档
>
> Apifox是一款集API 文档、API 调试、API Mock、API 自动化测试等一体的软件
>
> 应科博客的在线文档地址: https://apifox.com/apidoc/shared-803bd8c3-c6da-44ab-a611-737f035da4c2/api-78995977

<img src=".\image\36.Api接口文档.png" style="zoom:73%;" />

<img src=".\image\56.Apifox返回响应.png" style="zoom:73%;" />

### 2.8.Sa-token安全框架的使用

> sa-token是一款国产开源的安全框架, 相比spring security它更轻量级, 配置简单, 上手简单

1.完整的登录认证流程

![](https://oss.dev33.cn/sa-token/doc/g/g3--login-auth.gif)

```java
@RestController
@RequestMapping("/user")
@CrossOrigin
@Slf4j
public class LoginController {

    @Autowired
    private UserMapper userMapper;

    @Value("${tiantianstudy.password-key}")
    private String passwordKey;

    @PostMapping("/login")
    public Result doLogin(@RequestBody User user) {
        // 密码加密与数据库密码对比
        String ciphertext = SaSecureUtil.aesEncrypt(passwordKey, user.getPassword());
        User loginUser = userMapper.selectEmailAndPassword(user.getEmail(), ciphertext);

        // 若没有查询到用户则直接返回错误信息
        if (Objects.isNull(loginUser)) {
            return new Result(404, "用户名或者密码错误");
        } else {
            // 根据账号id，进行登录 => 此处id为邮箱账号
            StpUtil.login(user.getEmail(), new SaLoginModel()
                    // jwt挂载的扩展参数
                    .setExtra("username", loginUser.getUsername())
                    .setExtra("headurl", loginUser.getHeadurl())
                    .setExtra("uid", loginUser.getUid())
                    .setExtra("email", loginUser.getEmail())
                    .setIsWriteHeader(true)
                    // 设置token过期时间 7天
                    .setTimeout(60 * 60 * 24 * 7)
            );

			// 将loginUser转化为UserDTO
            UserDTO userDTO = BeanUtil.copyProperties(loginUser, UserDTO.class);
            HashMap<Object, Object> res = new HashMap<>();
            // 再把Token的信息和用户信息返回给前端
            res.put("userDTO",userDTO);
            res.put("TTtoken",StpUtil.getTokenInfo());
            return new Result(200, "登录成功", res);
        }
    }

    /**
     * <h2>退出登录
     */
    @PostMapping("/logout")
    public SaResult logout() {
        StpUtil.logout();
        return SaResult.ok();
    }

    /**
     * <h2>查看登录会话是否登录
     */
    @GetMapping("/is-login")
    public Result isLogin() {
        // 查看当前会话是否登录
        boolean isLogin = StpUtil.isLogin();
        return new Result(isLogin ? 200 : 403, isLogin ? "用户已经登录" : "用户未登录无权操作");
    }
    
}
```

当登录成功的时候前端收到的信息如下

```json
{
    "data": {
        "TTtoken": {
            "tokenName": "TTtoken",
            "tokenValue": "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJsb2dpblR5cGUiOiJsb2dpbiIsImxvZ2luSWQiOiIxOTc5MjE0MDY5QHFxLmNvbSIsInJuU3RyIjoiNzFyak45ZkxlMFB4eDcxOXRRQnNYOWVsZ0xFSzhzTVciLCJ1c2VybmFtZSI6IlRpYW5UaWFuQWRtaW4iLCJoZWFkdXJsIjoiaHR0cHM6Ly9teS13ZWItb3NzLm9zcy1jbi1iZWlqaW5nLmFsaXl1bmNzLmNvbS9kYWY1NzA4Ni04NDcxLTQ4NjctYjViMC1iZmI5Njk4ZWJhNTgucG5nIiwidWlkIjoxLCJlbWFpbCI6IjE5NzkyMTQwNjlAcXEuY29tIn0.rSS4rzaxIAW50i2gIbC6_ZiaRjnXtjg26aR7M_kLXsI",
            "isLogin": true,
            "loginId": "1979214069@qq.com",
            "loginType": "login",
            "tokenTimeout": 604800,
            "sessionTimeout": -1,
            "tokenSessionTimeout": -2,
            "tokenActivityTimeout": -1,
            "loginDevice": "default-device",
            "tag": null
        },
        "userDTO": {
            "uid": 1,
            "username": "TianTianAdmin",
            "email": "1979214069@qq.com",
            "headurl": "https://my-web-oss.oss-cn-beijing.aliyuncs.com/daf57086-8471-4867-b5b0-bfb9698eba58.png"
        }
    },
    "code": 200,
    "message": "登录成功"
}
```

做好Redis相关配置后, Sa-token会自动将token写入Redis, 读取时也会从Redis中读取

由于我这个是测试账号, 所以设置了token过期时间(TTL)为-1(永不过期)

<img src=".\image\27.Redis存放位置.png" style="zoom:70%;" />

前端js代码逻辑如下

```js
import {isLogin, login} from "@/api/user/user";

export default {
  name: "Login",
  data() {
    return {
      // 数据模型
      userLoginInfo: {
        email: '',
        password: ''
      }
    }
  },
  components: {
    graphicLoading
  },
  created() {
    // 组件实例化后 判断是否有token(合法)/是否已经登录 => 若有 已经登录 => 直接跳转到home
    isLogin().then((res) => {
      if (res.data.code === 200) {
        this.$router.replace('/main');
      }
    })
  },
  methods: {
    
    login() {
      // 判断邮箱是否为空
      if (this.userLoginInfo.email === '') {
        this.$notify({
          title: '警告',
          message: '邮箱号不能为空,请输入邮箱号',
          type: 'warning'
        });
        return
      }
      // 判断邮箱是否合法
      if (!/^([a-zA-Z\d][\w-]{2,})@(\w{2,})\.([a-z]{2,})(\.[a-z]{2,})?$/.test(this.userLoginInfo.email)) {
        this.$notify.error({
          title: '错误',
          message: '你输入的邮箱号不合法,请重写输入'
        });
        return
      }
      // 判断密码是否为空
      if (this.userLoginInfo.password === '') {
        this.$notify({
          title: '警告',
          message: '密码不能为空,请输入密码',
          type: 'warning'
        });
        return
      }
      login(this.userLoginInfo).then((res) => {
        // 状态码200代表登录成功
        if (res.data.code === 200) {
          // 将userDTO和token值都存在localStorage中
          localStorage.setItem(res.data.data.TTtoken.tokenName, res.data.data.TTtoken.tokenValue)
          localStorage.setItem("userInfo", JSON.stringify(res.data.data.userDTO))
          // 跳转到首页
          this.$router.replace('/main');
          // 登录成功 输出欢迎语
          const h = this.$createElement;
          this.$message({
            type: 'success',
            message: h('p', null, [
              h('span', null, '欢迎回来'),
            ])
          });
        } else {
          this.$notify.error({
            title: '错误',
            message: '邮箱名或者密码错误'
          });
        }
      }).catch(error => {
        console.log(error.message)
      })
    },
  }
}
```

前端请求拦截器 具体代码请返回上面查看`对axios的二次封装`

```js
instance.interceptors.request.use((config) => {
 NProgress.start()
 // 每次请求都带上token
 const token = localStorage.getItem("TTtoken")
 token ? config.headers["TTtoken"] = token : null;
 
 return config;
}, function (error) {
 Message.error("请求错误")
 return Promise.reject(error);
});
```

后端拦截器

```java
@Configuration
public class SaTokenConfigure implements WebMvcConfigurer {

    // Sa-Token 整合 jwt (Simple 简单模式)
    @Bean
    public StpLogic getStpLogicJwt() {
        return new StpLogicJwtForSimple();
    }

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        // 注册 Sa-Token 拦截器，定义详细认证规则
        registry.addInterceptor(new SaInterceptor(handler -> {
            // 指定一条 match 规则
            SaRouter
                    // 拦截的path，拦截所有
                    .match("/**")
                	// 排除掉的path 排序登录和注册
                    .notMatch("/user/login")        
                    .notMatch("/register");
        }));
    }
}
```

注册逻辑的实现 后端代码

<img src=".\image\54.收到注册验证码.png" style="zoom:70%;" />

<img src=".\image\55.已经注册.png" style="zoom:70%;" />

```java
@RestController
@RequestMapping("/register")
@CrossOrigin
public class RegisterController {

    @Autowired
    private UserMapper userMapper;

    @Value("${tiantianstudy.password-key}")
    private String passwordKey;

    @Autowired
    private SendMailService sendMailService;

    @Autowired
    private StringRedisTemplate stringRedisTemplate;

    @Autowired
    private BaseUserInfoMapper baseUserInfoMapper;

    @PostMapping
    @Transactional // 涉及到两张表的操作 所以要开启事务
    public Result register(@RequestBody User user) {
        if (!Objects.isNull(userMapper.selectUserInfoOne(user.getEmail()))) {
            return Result.failure("该邮箱已存在");
        } else {
            // 加密存储
            user.setPassword(SaSecureUtil.aesEncrypt(passwordKey, user.getPassword()));
            // 新增用户信息
            int count1 = userMapper.insertUserInfo(user);
            Integer uid = user.getUid();
            // 初始化用户信息
            BaseUserInfo baseUserInfo = new BaseUserInfo();
            baseUserInfo.setUid(uid);
            baseUserInfo.setUsername(user.getUsername());
            // 添加默认语言Java
            ArrayList<String> label = new ArrayList<>(Collections.singletonList("Java"));
            baseUserInfo.setLabel(label);
            int count2 = baseUserInfoMapper.insert(baseUserInfo);
            // 定制返回信息
            String msg = count1 * count2 > 0 ? "注册成功" : "注册失败";
            return new Result(200, msg);
        }
    }


    @PostMapping("/simple/{email}")
    public Result SendVerificationCodeMessage(@PathVariable String email) {
        String verification6Code = VerificationCodeUtils.getVerification6Code();

        MailRequest mailRequest = new MailRequest();
        mailRequest.setSubject("应科博客");
        mailRequest.setSendTo(email);
        // 存入Redis设置5分钟之后过期
        String key = REGISTER_V_CODE + email;
        stringRedisTemplate.opsForValue().set(key, verification6Code, 5, TimeUnit.MINUTES);

        mailRequest.setText("【应科博客】，尊敬的应科博客用户，您正在注册，您的你的验证码为: " + verification6Code + "，该验证码5分钟内有效，请勿泄露他人。");
        mailRequest.setFrom("1979214069@qq.com" + "(应科博客)");
        sendMailService.sendSimpleMail(mailRequest);
        return Result.ok();
    }

    @PostMapping("/verification/{email}/{code}")
    public Result verification(@PathVariable String email, @PathVariable String code) {
        String key = REGISTER_V_CODE + email;
        String codeCache = String.valueOf(stringRedisTemplate.opsForValue().get(key));
        System.out.println("codeCache" + codeCache);
        if (codeCache == null || codeCache.equals("")) {
            return Result.failure();
        }

        if (StrUtil.equals(codeCache, code)) {
            // 验证成功后直接删除缓存 并返回状态码200给前端
            stringRedisTemplate.delete(key);
            return Result.ok();
        } else {
            return Result.failure();
        }
    }
}
```

### 2.9.封装UserHolder

> UserHolder可以直接在jwt类型的token中获取用户信息(在登录时已经将token给用户了), 在应科博客中大量使用了UserHolder,封装UserHolder有以下的优点:
>
> 1. 方便, 前端不用每次都传常用的uid和email过来, 直接在jwt中解析即可, 大大减小了前端的工程量
> 2. 安全, 使用了UserHolder的方法通常是一些权限高的方法, 例如增删改等操作, 不用在判断是否为登录用户了, 若jwt解析失败就被2.3中的全局异常给捕获到了

```java
/**
 * 从JWT中获取用户的信息
 * 此类所有方法必须在用户登录的状态下才能使用
 */
public class UserHolder {
    public static String getUsername() {
        return StpUtil.getExtra("username").toString();
    }

    public static String getHeadurl() {
        return StpUtil.getExtra("headurl").toString();
    }

    public static Integer getUid() {
        return (Integer)StpUtil.getExtra("uid");
    }

    public static String getEmail() {
        return StpUtil.getExtra("email").toString();
    }

    public static UserDTO getUserDTO() {
        return new UserDTO(getUid(), getUsername(), getEmail(), getHeadurl());
    }

}
```

## 3.核心功能代码

### 3.1.分页实现

> - 前端基于`element`封装的分页组件 [pagination](https://element.eleme.cn/#/zh-CN/component/pagination#dai-you-bei-jing-se-de-fen-ye)
> - 后端基于`mybatis`的轻量级分页插件[pageHelper](https://github.com/pagehelper/Mybatis-PageHelper)
>
> 两个插件配合使用仅需十几行即可实现

#### 后端代码

1. `BlogController`

```java
@GetMapping("/get-all") // 映射路径 接受page pageSize参数默认值分别为1和6
public Result getAll(@RequestParam(value = "page", defaultValue = "1", required = false) Integer page,
                     @RequestParam(value = "pageSize", defaultValue = "6", required = false) Integer pageSize) {
    // 使用PageHelper设置分页数据
    PageHelper.startPage(page, pageSize);
    // 查询到数据封装到blogPage中
    Page<Blog> blogPage = (Page<Blog>) blogMapper.selectAll();
    // 返回结果和总记录数
    String totalString = Long.toString(blogPage.getTotal());
    return new Result.ok(totalString, blogPage.getResult());
}
```

2. `BlogMapper.xml`中的selectAll()方法, 由于业务不多, 所以直接调用mapper层, 省略了Service层

```xml
<select id="selectAll" resultType="com.tiantian.pojo.Blog">
  select blog_id, username, title, label, release_time
  from blog
</select>
```

#### 前端代码

1. [分页组件配置详细介绍(ctrl+左键进行跳转)](https://element.eleme.cn/#/zh-CN/component/pagination#dai-you-bei-jing-se-de-fen-ye)

<img src=".\image\09.分页功能实现.png" style="zoom:80%;" />

```vue
<!--分页-->
<div class="block">
    <el-pagination
        @size-change="handleSizeChange"
        @current-change="handleCurrentChange"
        :current-page="pagination.page"
        :page-sizes="[6, 8, 10, 15]"
        :page-size="pagination.pageSize"
        layout="total, sizes, prev, pager, next, jumper"
        :total="pageTotal">
    </el-pagination>
</div>
```

2. 数据模型

```js
<!--分页数据模型-->
pageTotal: 0, 		//总记录数
pagination: {		//分页相关模型数据
  page: 1, 			//当前页码
  pageSize: 6, 		// 每页要展示多少条数据 默认为1页6条
}
```

3. 相关方法

```js
methods: {
  // 当页码发送改变的时候执行 val就是当前的页码
  handleCurrentChange(val) {
    this.pagination.page = val
    // 重新发送请求携带请求参数获取分页数据
    this.getAll()
  },
  // 当每页展示数发生变化时执行 val就当前每页展示数, 我设置的参数有[6, 8, 10, 15] 既每页展示6条/8条/10条/15条
  handleSizeChange(val) {
    this.pagination.pageSize = val
    // 重新发送请求获取分页数据
    this.getAll()
  },

  // 发送请求获取分页数据 getAll方法已经封装在'api/blogApi'中
  getAll() {
    // this.pagination为分页数据的模型
    getAllBlog(this.pagination).then(res => {
      this.blog_list = res.data.data
      // 获取到页码总数 => 组件会自动计算出一共有多少页码
      this.pageTotal = parseInt(res.data.message)
    })
  },
}
```

### 3.2.图片上传和下载实现

> 此功能分为本地文件的上传和下载和使用了[阿里云OSS存储](https://help.aliyun.com/document_detail/32011.html?spm=a2c4g.32008.0.0.2aeec9276pTlwE)的上传和下载(推荐)

#### 前端代码

1.[上传组件详细配置介绍(ctrl+点击进行跳转)](https://element.eleme.cn/#/zh-CN/component/upload)

<img src=".\image\13.头像的上传和下载.png" style="zoom:67%;" />

```vue
<el-upload class="avatar-uploader"
           :action="uploadUrl"
           :headers="headers"
           :show-file-list="false"
           :on-success="handleAvatarSuccess"
           :before-upload="beforeUpload"
           ref="upload">

    <!--当用户头像不为空时 显示从localStorage中获取的这张图-->
    <img v-if="userInfo.headurl !== ''" :src="userInfo.headurl" width="150px" height="150px"
         style="border-radius: 300px;margin-left: 8%" alt="userImage">
    <!--当用户头像为扣时显示这张图片defaultUserUrl-->
    <img v-else :src="defaultUserUrl" width="150px" height="150px"
         style="border-radius: 300px;margin-left: 8%" alt="userImage">

    <i>
        <el-button size="mini">更换头像</el-button>
    </i>
</el-upload>
```

2.数据模型

```js
userInfo: {
    uid: '',
    headurl: '',
    username: '',
    email: ''
  },
// 当用户没有设置头像的时候 默认展示这张图片
defaultUserUrl: require('@/assets/img/defaultUserUrl.png'),
// 图片上传的地址
uploadUrl: 'http://localhost/common/oss/upload'
  }
}
```

3.相关方法

```js
methods: {
  handleAvatarSuccess(response, file, fileList) {
    this.userInfo.headurl = response.message
    getUserDTO().then((res) => {
      this.userInfo = res.data.data
      // 重新将最新的userInfo存入localStorage中
      localStorage.setItem("userInfo", JSON.stringify(res.data.data))
    })
    this.$message({
      showClose: true,
      message: '修改成功',
      type: "success"
    });
    // 刷新页面 重新获取头像信息
    setTimeout(() => {
      location.reload()
    }, 1100);
  },
  
  beforeUpload(file) {
    if (file) {
      // 截取文件后缀
      const suffix = file.name.substring(file.name.lastIndexOf(".") + 1);
      // 判断文件大小是否符合规则
      const size = file.size / 1024 / 1024 < 2
      if (['png', 'jpeg', 'jpg'].indexOf(suffix) < 0) {
        this.$message.error('上传图片只支持 png、jpeg、jpg 格式！')
        this.$refs.upload.clearFiles()
        return false
      }
      if (!size) {
        this.$message.error('上传文件大小不能超过 2MB!')
        return false
      }
      return file
    }
  }
}
```

#### 后端代码

方案一: 使用阿里云OSS对象存储服务(安全 简单 易用)

`aliOSSUtils`的封装

> 要在阿里云开通OSS服务, 并选区再创建bucketName最后获取到accessKeyId和accessKeySecret直接填入工具类中即可
>
> 如果你不想动, 也可以直接使用我的accessKey

但不要上传视频

<img src=".\image\56.阿里云存储欠费.jpg" style="zoom:40%;" />

```java
/**
 * 阿里云 OSS 工具类
 */
@Component
@SuppressWarnings("all")
public class AliOSSUtils {

    private final String endpoint = "https://oss-cn-beijing.aliyuncs.com";
    private final String accessKeyId = "LTAI5tB3eHWYJ4dxPr8p13wK";
    private final String accessKeySecret = "LcSYOiAz3jeUEM0BI5M8j7TbPuwxmc";
    private final String bucketName = "my-web-oss";

    /**
     * 实现上传图片到OSS
     */
    public String upload(MultipartFile file) throws IOException {
        // 获取上传的文件的输入流
        InputStream inputStream = file.getInputStream();

        // 避免文件覆盖 => 使用UUID
        String originalFilename = file.getOriginalFilename();
        // 拼接文件后缀
        String fileName = UUID.randomUUID() + originalFilename.substring(originalFilename.lastIndexOf("."));

        // 上传文件到 OSS
        OSS ossClient = new OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret);
        ossClient.putObject(bucketName, fileName, inputStream);

        // 文件访问路径
        String url = endpoint.split("//")[0] + "//" + bucketName + "." + endpoint.split("//")[1] + "/" + fileName;
        // 关闭ossClient
        ossClient.shutdown();
        // 把上传到oss并把图片地址返回
        return url;
    }
    
     /**
     * 从OSS中删除文件
     * @param fileName
     */
    public Integer delFile(String fileName){

        // 创建OSSClient实例。
        OSS ossClient = new OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret);

        try {
            // 删除指定Object
            VoidResult voidResult = ossClient.deleteObject(bucketName, fileName);
            // 没有错误信息 则代表删除成功
            return 200;
        } catch (OSSException oe) {
            System.out.println("Caught an OSSException, which means your request made it to OSS, "
                    + "but was rejected with an error response for some reason.");
            System.out.println("Error Message:" + oe.getErrorMessage());
            System.out.println("Error Code:" + oe.getErrorCode());
            System.out.println("Request ID:" + oe.getRequestId());
            System.out.println("Host ID:" + oe.getHostId());
        } catch (ClientException ce) {
            System.out.println("Caught an ClientException, which means the client encountered "
                    + "a serious internal problem while trying to communicate with OSS, "
                    + "such as not being able to access the network.");
            System.out.println("Error Message:" + ce.getMessage());
        } finally {
            if (ossClient != null) {
                ossClient.shutdown();
            }
        }
        return 400;
    }
}
```

`CommonController`

```java
@Autowired
private AliOSSUtils aliOSSUtils;

@Autowired
private UserMapper userMapper;

@PostMapping("/oss/upload")
@SaCheckLogin
public Result uploadByAliOOS(MultipartFile file) throws Exception {
    String url = aliOSSUtils.upload(file);
    // 将用户头像地址写入/更新到数据库 最后返回给前端
    userMapper.updateHeadUrl(url, UserHolder.getUid());
    return Result.ok(url);
}
```

方案二:

保存到本地中 并通过io读取返回前端 (不推荐, 较为复杂且有丢失的风险)

```java
/**
 * <h1>文件的上传和下载</h1> 必须携带token才能进行访问<br/>
 * 两套方案 => 分别为通过IO流进行本地存储和使用阿里云的OOS免费服务进程存储(推荐)
 */
@RestController
@RequestMapping("/common")
@CrossOrigin
@SuppressWarnings("all")
@Slf4j
public class CommonController {

    /**
     * <h1>本地存储</h1>
     */

    @Value("${tiantianstudy.path}")
    private String basePath;

    @PostMapping("/upload")
    @SaCheckLogin
    public Result upload(MultipartFile file) {
        //  获取原始文件名 但可以会导致文件重复进而覆盖文件
        String originalFilename = file.getOriginalFilename();
        // 截取缀
        String suffix = null;
        if (originalFilename != null) {
            suffix = originalFilename.substring(originalFilename.lastIndexOf("."));
        }
        // 使用UUID 防止重复
        String fileName = UUID.randomUUID() + suffix;

        File dir = new File(basePath);
        if (!dir.exists()) {
            dir.mkdirs();
        }

        try {
            // 将临时文件转存在指定位置
            file.transferTo(new File(basePath + fileName));
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
        System.out.println("创建文件" + fileName);
        // 拼接URL
        String URL = "http://localhost/common/download/" + fileName;
        return new Result(200, URL);
    }

    @GetMapping("/download/{name}")
    public void download(@PathVariable String name, HttpServletResponse response) {
        System.out.println("图片的名称 = " + name);
        try {
            FileInputStream fileInputStream = new FileInputStream(basePath + name);
            ServletOutputStream outputStream = response.getOutputStream();
            response.setContentType("image/jpeg");

            int len;
            byte[] bytes = new byte[1024];
            while ((len = fileInputStream.read(bytes)) != -1) {
                outputStream.write(bytes, 0, len);
                outputStream.flush();
            }

        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }


    /**
     * 删除文件
     * @param fileName
     * @return
     */
    @PostMapping("/delete/{fileName}")
    public Result deleteFile(@PathVariable String fileName) {
        System.out.println("删除文件的名称为: " + fileName);

        try {
            // 拼接路径
            String filePath = basePath + fileName;
            File myDelFile = new File(filePath);
            // 删除指定文件
            boolean delete = myDelFile.delete();
            if (delete) return Result.ok();
            else return Result.failure();
        } catch (Exception e) {
            System.out.println("删除文件操作出错");
            e.printStackTrace();
        }
        return Result.failure();
    }


    /**
     * <h1 style="color: yellow">使用阿里云OOS进行存储</h1>
     */

    @Autowired
    private AliOSSUtils aliOSSUtils;

    @Autowired
    private UserMapper userMapper;

    @PostMapping("/oss/upload")
    @SaCheckLogin
    public Result uploadByAliOOS(MultipartFile file) throws Exception {
        log.info("文件上传, 文件名: {}", file.getOriginalFilename());
        String url = aliOSSUtils.upload(file);
        log.info("文件上传完成, 文件访问的url: {}", url);
        // 将用户头像地址写入数据库 并返回给前端
        userMapper.updateHeadUrl(url, UserHolder.getUid());
        return new Result(200, url);
    }
}
```

#### 在mavon-editor中上传图片实现

> 这里使用的是本地保存图片 因为阿里云免费存储空间有限

上传图片

<img src=".\image\46.上传按钮展示.png" style="zoom:80%;" />



返回地址

<img src=".\image\48.返回图片地址.png" style="zoom:80%;" />

删除图片

<img src=".\image\47.删除图片.png" style="zoom:80%;" />



#### 前端代码

1.给mavon-editor添加@imgAdd和@imgDel两个事件

`@imgAdd`是当用户添加图片时执行

`@imgDel`是当用删除图片时执行

```vue
<mavon-editor
  v-model="article.context"
  ref="md"
  @imgAdd="handleEditorImgAdd"
  @imgDel="handleEditorImgDel"
  @change="change"
  class="my-editor"
/>
```

相关方法

```js
handleEditorImgAdd(pos, $file) {
  let formData = new FormData()
  formData.append('file', $file)
  console.log('formData', formData)
  // 发送请求 (前端调用的是同一个接口)
  uploadImg(formData).then(res => {
    if (res.data.code === 200) {
      Message.success("上传成功")
      // 上传成功 后端传递图片地址回来
      let url = res.data.message
      let name = $file.name
      if (name.includes('-')) {
        name = name.replace(/-/g, '')
      }
      let content = this.article.context
      // 第二步 转化为markdown语法格式 将返回的url替换到文本原位置![...](0) -> ![...](url)
      if (content.includes(name)) {
        let oStr = `(${pos})`
        let nStr = `(${url})`
        let index = content.indexOf(oStr)
        let str = content.replace(oStr, '')
        let insertStr = (source, start, newStr) => {
          return source.slice(0, start) + newStr + source.slice(start)
        }
        this.article.context = insertStr(str, index, nStr)
        console.log(insertStr(str, index, nStr))
      }
    } else {
      Message.error("上传失败")
    }
  })
},
handleEditorImgDel(pos) {
   let fileName = pos[1]['name']
   console.log("删除图片的名称为: ", fileName)
   deleteImg(fileName).then((res) => {
      if (res.data.code === 200) {
        Message.success("删除图片成功");
        // 删除图片对应markdown内容
        let removeFileName = fileName.replace("-","");
        this.article.context.replace(`![${removeFileName}](http://localhost/common/download/${fileName})`,"")
     } else {
        Message.error("删除图片失败")
     }
   })
},
```

### 3.3.每日刷题功能实现

编程题模块

<img src=".\image\42.编程题模块.png" style="zoom:80%;" />选择题模块

<img src=".\image\43.选择题模块.png" style="zoom:80%;" />

解答题模块 + 提交按钮

![](.\image\44.解答题模块.png)

提交模块

<img src=".\image\45.提交答案模块.png" style="zoom:70%;" />

查看解析模块

<img src=".\image\41.题目解析模块.png" style="zoom:100%;" />

发布解题: 当按下按钮后会跳转到写博客的页面, 并会自动生成模板(标题, 标签, 内容)

<img src=".\image\49.发布解题模块.png" style="zoom:67%;" />

#### 前端代码

答题界面

```vue
<template>
  <div class="container">
    <!--编程题-->
    
    <h4 class="mt-3" style="float: left;">每日刷题</h4>
    
    <el-tabs v-model="activeName" type="card" style="float: right;" class="mt-3" @tab-click="handleClick">
      <el-tab-pane :disabled="isAnswer" :label="answerForm.programmingAnswer === '' ?'编程题':'编程题✔️'"
                   name="first"></el-tab-pane>
      <el-tab-pane :disabled="isAnswer" :label="answerForm.chooseAnswer === '' ?'选择题':'选择题✔️'" name="second"></el-tab-pane>
      <el-tab-pane :disabled="isAnswer" :label="answerForm.jQuestionAnswer === ''?'解答题':'解答题✔️'" name="third"></el-tab-pane>
    </el-tabs>
    <div style="clear: both"></div>
    
    <!--编程题-->
    <div v-show="index === 0" class="card" style="width: 468px;height: 400px;float: left;overflow-y: scroll">
      <div class="card-body">
        <h6 class="card-title">{{ aQuestion.title }}</h6>
        <span style="font-size: 10px">难度: </span>
        <el-tag>{{ aQuestion.level }}</el-tag>
        <span style="font-size: 10px;margin-left: 10px;">类型: </span>
        <el-tag>{{ aQuestion.language }}</el-tag>
        <!--题目内容区域-->
        <p class="card-text" style="font-size: 16px;margin-top: 10px;">{{ aQuestion.question }}</p>
        <h6 style="color: #6c757d">示例1</h6>
        <!--示例区域 bgc: #f2f3f4-->
        <div class="top-example">
          {{ aQuestion.exampleOne }}
        </div>
        <h6 style="color: #6c757d">示例2</h6>
        <div class="top-example">
          {{ aQuestion.exampleTwo }}
        </div>
      
      
      </div>
    </div>
    <IDE v-show="index === 0" code-mode="text/x-java"
         style="width: 788px; float: right;"
         @getCodeAnswer="getCodeAnswer"/>
    
    <!--选择题-->
    <div v-show="index === 1">
      <div class="card" style="width: 25rem;height: 22rem;float: left;overflow-y: scroll">
        <div class="card-body">
          <span style="font-size: 10px">难度: </span>
          <el-tag>{{ bQuestion.level }}</el-tag>
          <span style="font-size: 10px;margin-left: 10px;">类型: </span>
          <el-tag>{{ bQuestion.type }}</el-tag>
          <div class="ueditor">
            <mavon-editor
              class="markdown-body"
              v-highlight ref="md"
              codeStyle="github"
              :ishljs="true"
              v-html="codeDataHtml">
            </mavon-editor>
          </div>
        </div>
      </div>
      
      <div style="border: 1px solid #6c757d; border-radius: 10px;height: 400px;">
        <p class="card-text" style="display: inline-block;margin-left: 20px;">{{ bQuestion.question }}</p>
        <br>
        <el-radio v-model="answerForm.chooseAnswer" class="el-radio" label="A" border>{{ bQuestion.aanswer }}</el-radio>
        <br>
        <el-radio v-model="answerForm.chooseAnswer" class="el-radio" label="B" border>{{ bQuestion.banswer }}</el-radio>
        <br>
        <el-radio v-model="answerForm.chooseAnswer" class="el-radio" label="C" border>{{ bQuestion.canswer }}
        </el-radio>
        <br>
        <el-radio v-model="answerForm.chooseAnswer" class="el-radio" label="D" border>{{ bQuestion.danswer }}
        </el-radio>
      </div>
    </div>
    
    <!--解答题-->
    <div v-show="index === 2" style="height: 400px">
      {{ cQuestion.question }}
      <el-input
        style="font-size: 15px"
        type="textarea"
        :autosize="{ minRows: 15}"
        placeholder="请输入你的答案"
        maxlength="1000"
        show-word-limit
        v-model="answerForm.jQuestionAnswer">
      </el-input>
      <el-button style="float: right;margin-top: 10px;" @click="submit">提交所有</el-button>
    </div>
    
    <!--成功提示-->
    <div v-show="index === 3">
      <el-result icon="success" title="今日刷题已完成" subTitle="请等待分数公布 并自行看解析">
        <template slot="extra">
          <el-button type="primary" size="medium" @click="gotoQuestionParse">查看解析</el-button>
        </template>
        <template slot="extra">
          <el-button type="primary" size="medium" @click="gotoWriteBlog()">发布解题</el-button>
        </template>
      </el-result>
    </div>
    
    <!--查看解析-->
    <div v-show="index === 4">
      <topic-analysis/>
    </div>
    <div style="clear: both;"></div>
    <br>
    <br>
    <br>
    <br>
  </div>
</template>

<script>
import IDE from "@/pages/heartfelt-content/training/IDE.vue";
import {marked} from "marked";
import 'mavon-editor/dist/markdown/github-markdown.min.css'
import {mavonEditor} from "mavon-editor";
import {addAnswerUser, getAllTopic, isAnswer} from "@/api/topic/topic";
import {getTime, getTime2} from "@/utils/DateFormatting";

export default {
  name: "Training",
  components: {
    IDE,
    mavonEditor,
  },
  created() {
    getAllTopic().then((res) => {
      this.aQuestion = res.data.data.a
      this.bQuestion = res.data.data.b
      this.cQuestion = res.data.data.c
    })
    setTimeout(() => {
      this.markdownChangeHtml()
    }, 200)
    // 查看用户是否已经做完每日一题
    isAnswer().then((res) => {
      if (res.data.code === 200) {
        this.index = 3
        this.programmingAnswer = '1'
        this.chooseAnswer = '1'
        this.jQuestionAnswer = '1'
        this.isAnswer = true
      }
    })
  }
  ,
  data() {
    return {
      index: 0, // 题目索引
      codeDataHtml: '',
      isAnswer: false,
      codeDataMarkDown: '',
      activeName: 'first',
      aQuestion: {},
      bQuestion: {},
      cQuestion: {},
      answerForm: {
        programmingAnswer: '',
        chooseAnswer: '',
        jQuestionAnswer: '',
      }
    }
  },
  computed: {},
  methods: {
    // 将markdown转化为html展示给用户
    markdownChangeHtml() {
      this.codeDataHtml = marked(this.bQuestion.exampleCode)
    },
    handleClick(event) {
      this.index = event.index * 1
    },
    getCodeAnswer(code) {
      this.answerForm.programmingAnswer = code
    },
    submit() {
      // 非空校验
      if (this.answerForm.programmingAnswer === '') {
        this.$message.error("编程题答案不能为空");
        return
      }
      if (this.answerForm.chooseAnswer === '') {
        this.$message.error("选择题题答案不能为空");
        return
      }
      if (this.answerForm.jQuestionAnswer.length < 50) {
        this.$message.error("解答题题答案不能字数不能少于50字");
        return
      }
      // 添加答题用户信息
      addAnswerUser(this.answerForm).then((res) => {
        if (res.data.code === 200) {
          this.$message.success("提交成功");
          this.index = 3
        } else {
          this.$message.error("提交失败");
        }
      })
    },
    // 跳转到写博客页面并带上参数
    gotoWriteBlog() {
      this.$router.replace({
        path: '/blog/write-article',
        query: {
          title: '今日解题' + getTime2(new Date),
          label: '解题',
          context: '# 我的解题思路如下\n' +
            '\n' +
            '1. 编程题\n' +
            '\n' +
            '   \n' +
            '\n' +
            '2. 选择题\n' +
            '\n' +
            '\n' +
            '\n' +
            '3. 解答题',
        }
      })
    },
    gotoQuestionParse() {
      // 跳转到题目解析页面
      this.$router.replace('/question-parse')
    }
  },
}
</script>

<style scoped lang="css">
.top-example {
  padding: 10px;
  background-color: #f2f3f4;
  font-size: 13px;
  border-radius: 10px;
  margin-top: 10px;
}

.ueditor {
  margin-top: 20px;
}

.el-radio {
  margin: 20px;
}
</style>
```

解析题目界面

```vue
<template>
  <div class="container" style="background-color: #f2f2f2;border-radius: 18px">
    <h3 class="q-parse">编程题解析</h3>
    <h5 style="float: right">{{getTime2(new Date)}}</h5>
    <br>
    <div style="clear: both"></div>
    <!--编程题-->
    <div class="card" style="width: 468px;height: 400px;float: left;overflow-y: scroll">
      <div class="card-body">
        <h6 class="card-title">{{ aQuestion.title }}</h6>
        <span style="font-size: 10px">难度: </span>
        <el-tag>{{ aQuestion.level }}</el-tag>
        <span style="font-size: 10px;margin-left: 10px;">类型: </span>
        <el-tag>{{ aQuestion.language }}</el-tag>
        <!--题目内容区域-->
        <p class="card-text" style="font-size: 16px;margin-top: 10px;">{{ aQuestion.question }}</p>
        <h6 style="color: #6c757d">示例1</h6>
        <!--示例区域 bgc: #f2f3f4-->
        <div class="top-example">
          {{ aQuestion.exampleOne }}
        </div>
        <h6 style="color: #6c757d">示例2</h6>
        <div class="top-example">
          {{ aQuestion.exampleTwo }}
        </div>
      </div>
    </div>
    
    <IDE code-mode="text/x-java"
         :init-code="aQuestion.rightAnswer"
         class="ide"
         @getCodeAnswer="getCodeAnswer"/>
    <div style="clear: both"></div>
    <br>
    <br>
    
    <!--选择题-->
    <div>
      <h3 class="q-parse">选择题解析</h3>
      <div class="card" style="width: 25rem;height: 450px;float: left;overflow-y: scroll">
        <div class="card-body">
          <span style="font-size: 10px">难度: </span>
          <el-tag>{{ bQuestion.level }}</el-tag>
          <span style="font-size: 10px;margin-left: 10px;">类型: </span>
          <el-tag>{{ bQuestion.type }}</el-tag>
          <div class="ueditor">
            <mavon-editor
              class="markdown-body"
              v-highlight ref="md"
              codeStyle="github"
              :ishljs="true"
              v-html="codeDataHtml">
            </mavon-editor>
          </div>
        </div>
      </div>
      
      <div style="border: 1px solid #6c757d; border-radius: 10px;height: 450px;overflow-y: scroll">
        <p class="card-text" style="display: inline-block;margin-left: 20px;">{{ bQuestion.question }}</p>
        <br>
        <el-radio v-model="twoAnswer" class="el-radio" label="A" border>{{ bQuestion.aanswer }}</el-radio>
        <br>
        <el-radio v-model="twoAnswer" class="el-radio" label="B" border>{{ bQuestion.banswer }}</el-radio>
        <br>
        <el-radio v-model="twoAnswer" class="el-radio" label="C" border>{{ bQuestion.canswer }}
        </el-radio>
        <br>
        <el-radio v-model="twoAnswer" class="el-radio" label="D" border>{{ bQuestion.danswer }}
        </el-radio>
        <br>
        <div style="padding: 10px;">
          <el-tag type="success">解析:</el-tag>
          &nbsp;&nbsp;
          {{ bQuestion.rightAnswer }}
        </div>
      </div>
    </div>
    <div style="clear: both"></div>
    <br>
    <br>
    
    <!--解答题解析-->
    <h3 class="q-parse">解答题解析: {{bQuestion.question}}</h3>
    <mavon-editor
      class="markdown-body"
      v-highlight ref="md"
      code-style="github"
      :ishljs="true"
      v-html="CcodeDataHtml">
    </mavon-editor>
    <div style="clear: both"></div>
    <br>
    <br>
  </div>
</template>

<script>
import {getAllTopic} from "@/api/topic/topic";
import {marked} from "marked";
import IDE from "@/pages/heartfelt-content/training/IDE.vue";
import {getTime2} from "@/utils/DateFormatting";

export default {
  name: "QuestionParse",
  components: {
    IDE
  },
  data() {
    return {
      codeDataHtml: '', // 选择题的html格式的代码
      CcodeDataHtml:'', // 解答题的html格式的代码
      oneAnswer: '',    // 与ide组件间通信的桥梁
      twoAnswer: '',	// 选择题答案
      codeDataMarkDown: '',
      aQuestion: {},	// 编程题信息
      bQuestion: {},	// 选择题信息
      cQuestion: {}		// 解答题信息
    }
  },
  created() {
    // 依次赋值
    getAllTopic().then((res) => {
      this.aQuestion = res.data.data.a
      this.bQuestion = res.data.data.b
      this.cQuestion = res.data.data.c
    })
    // 延时加载
    setTimeout(() => {
      this.markdownChangeHtml()
    }, 500)
  },
  methods: {
    // 获取当前时间
    getTime2,
    markdownChangeHtml() {
      // 将markdown转化为html
      this.codeDataHtml = marked(this.bQuestion.exampleCode)
      this.CcodeDataHtml = marked(this.cQuestion.rightAnswer)
    },
    // 组件间通信的方法
    getCodeAnswer(code) {
      this.oneAnswer = code
    },
  }
}
</script>

<style scoped>
.el-radio {
  margin: 10px;
}
.top-example {
  padding: 10px;
  background-color: #f2f3f4;
  font-size: 13px;
  border-radius: 10px;
  margin-top: 10px;
}

.q-parse {
  padding: 10px;
  margin-top: 20px;
  text-align: center;
  border-radius: 10px;
  background-color: #f3baba;
}
    
.ide {
  width: 788px; float: right;
}

</style>
```

#### 后端代码

先大致了解一下表关系

<img src=".\image\31.题库数据库的设计.png" style="zoom:80%;" />

思路:

1. 从题目管理表`question_manage`中根据今日日期(格式yyyymmdd如`20230427`)获取出QuestionId
2. 注入三张题目表对应的Mapper 再根据QuestionId查询到三个题目的数据 封装到Map集合中 返回前端
3. 当答题完毕后发送post请求提交到后端直接插入数据即可

`QuestionController` 

```java
@RestController
@RequestMapping("/question")
@CrossOrigin
public class QuestionController {
    @Autowired
    private AnswerQuestionsMapper answerQuestionsMapper;

    @Autowired
    private ChooseMapper chooseMapper;

    @Autowired
    private ProgrammingMapper programmingMapper;

    @Autowired
    private QuestionManageMapper questionManageMapper;

    @Autowired
    private AnswerUserMapper answerUserMapper;


    /**
     * 获取今日题目信息
     */
    @GetMapping("/get-all")
    public Result getAll() {
        int nowCode = Integer.parseInt(DateFormat.getNowCode()); // 20230426 当前日期编号 这里先写死 因为题目太少了
        QuestionManage questionManage = questionManageMapper.selectByPrimaryKey(20230426);
        Integer questionId = questionManage.getQuestionId();
        HashMap<String, Object> questions = new HashMap<>();
        questions.put("a", answerQuestionsMapper.getByQuestionId(questionId));
        questions.put("b", chooseMapper.getByQuestionId(questionId));
        questions.put("c", programmingMapper.getByQuestionId(questionId));
        return Result.ok(questions);
    }

    /**
     * 添加答题用户
     * @param answerUser
     */
    @PostMapping("/answer-user")
    public Result addAnswerUser(@RequestBody AnswerUser answerUser) {
        int paperId = Integer.parseInt(DateFormat.getNowCode()); // 20230426 当前日期编号 这里先写死
        // 
        answerUser.setPaperId(20230426);
        answerUser.setUid(UserHolder.getUid());
        int count = answerUserMapper.insertSelective(answerUser);
        return Result.update(count);
    }

    /**
     * 判断用户是否已经完成了今日答题
     */
    @GetMapping("/is-answer")
    public Result isAnswer() {
        int nowCode = Integer.parseInt(DateFormat.getNowCode()); // 20230426 当前日期编号 这里先写死 因为题目有限了
        // 查询数据库中是否有用户id和题目的关系
        int count = answerUserMapper.countAnswerTodayIsAnswer(20230426, UserHolder.getUid());
        return Result.update(count);
    }
}
```

#### 实现每天更新

在`DateFormat.getNowCode()`方法中得到的就是今天的日期格式化(yyyymmdd), 而在questionManage维护着日期编码和问题的Id, 每一个问题的Id对应着三张表中唯一的题目, 所以仅需要在后台中添加充足的题目即可。

第二种实现方案请看`3.11`。

### 3.4.博客资源动态分类实现

<img src=".\image\08.高拓展性.png" style="zoom:80%;" />

#### 前端代码

数据模型

```js
labelList: []
```

相关方法

```js
  created() {
    // 在组件实例化之前获取到博客资源分类数据
    this.getLabelCount()
  },
    // 根据标签来获取博客信息
  GetBlogByLabel(label) {
    GetBlogByLabel(label).then((res) => {
      // 重写渲染数据
      this.blog_list = res.data.data
    })
  }
```

相关api

```js
export function GetBlogByLabel(label){
 return request({
  method: 'GET',
  url: `/blog/get-by-type/${label}` // 发送给后端的中BlogController的getByType方法
 })
}
```

最后通过v-for指令来遍历数据并展示给用户

#### 后端代码

`BlogController`

```java
@GetMapping("/get-by-type/{label}")
public Result getByType(@PathVariable String label) {
    return Result.ok(blogMapper.getBlogByLabel(label));
}
```

`blogMapper.xml中的getBlogByLabel` 根据标签查询, 将查询到的信息封装到`List<Blog>`中返回前端

```xml
  <select id="getBlogByLabel" resultType="com.tiantian.pojo.Blog">
    select blog_id,
           username,
           title,
           label,
           release_time
    from blog
    where label = #{label};
  </select>
```

`countTypeMapper.xml`

```xml
<select id="countType" resultMap="CountTypeMapperResultMap">
  select sum(label = 'java')       as java,
         sum(label = 'algorithm')  as algorithm,
         sum(label = 'essay')      as essay,
         sum(label = 'vue')        as vue,
         sum(label = 'css')        as css,
         sum(label = 'python')     as python,
         sum(label = 'JavaScript') as JavaScript
  from blog;
</select>
```

当需要新增类别的时候, 仅仅需要修改实体类`CountType`即可

### 3.5.博客删改查功能实现

#### 前端样式

在`个人中心的博客列表中`中我们可以对博客进行管理, 能够对博客的内容进行增删改查, 如图所示

<img src=".\image\15.博客的删改查.png" style="zoom:70%;" />

在点击编辑按钮时, 将会有弹出框, 并提示你显示修改博客的内容, 如下图

<img src=".\image\16.修改文章内容.png" style="zoom:70%;" />

删除和批量删除功能

<img src=".\image\17.删除和批量删除.png" style="zoom:67%;" />

#### 前端代码

这里使用了[el-table表格](https://element.eleme.cn/#/zh-CN/component/table#biao-wei-he-ji-xing), [el-dialog弹出框](https://element.eleme.cn/#/zh-CN/component/dialog), [el-select选择器](https://element.eleme.cn/#/zh-CN/component/select), [el-tag标签](https://element.eleme.cn/#/zh-CN/component/tag), [el-button按钮](https://element.eleme.cn/#/zh-CN/component/button), [el-input输入框](https://element.eleme.cn/#/zh-CN/component/input)组件 详细配置配置内容请点击跳转

1.表格内容展示区

```vue
<template>
  <el-table :data="tableData"
            @selection-change="handleSelectionChange"
            highlight-current-row
            ref="multipleTable"
            tooltip-effect="dark"
            border
            style="width: 100%">
    
    <el-table-column
      type="selection"
      width="55">
    </el-table-column>
    
    <el-table-column fixed prop="releaseTime" sortable label="发布日期" width="200">
    </el-table-column>
    
    <el-table-column prop="title" label="标题" width="260">
    </el-table-column>
    
    <el-table-column prop="label" label="标签" width="120">
      <template slot-scope="scope">
        <el-tag
          type="primary"
          disable-transitions>{{ scope.row.label }}
        </el-tag>
      </template>
    
    </el-table-column>
    
    <el-table-column prop="watch" label="观看人数" sortable width="120">
    </el-table-column>
    
    <el-table-column prop="star" label="点赞数量" sortable width="120">
    </el-table-column>
    
    <el-table-column prop="collection" label="收藏数量" sortable width="120">
    </el-table-column>
    
    <el-table-column fixed="right" label="操作" width="150">
      
      <template slot-scope="scope">
        <el-button @click="handleClick(scope.row);dialogFormVisible = true" size="mini">
            编辑
        </el-button>
        
        <el-button size="mini" @click="goto(scope.row)">
            查看
        </el-button>
        
        <template>
          <el-popconfirm
            confirm-button-text='取消'
            cancel-button-text='确定'
            @confirm="Cacneldel()"
            @cancel="sureDel(scope.row.blogId)"
            icon="el-icon-info"
            icon-color="red"
            title="是否删除该文章?一旦删除无法找回"
          >
            <el-button slot="reference" size="mini" style="margin-top: 5px; margin-left: 30px">删除</el-button>
          </el-popconfirm>
        </template>
      
      </template>
    
    </el-table-column>
  </el-table>
  <div class="block" style="margin-left: 300px;margin-top: 15px;">
    <el-pagination
        @size-change="handleSizeChange"
        @current-change="handleCurrentChange"
        :current-page="pagination.page"
        :page-sizes="[6, 8, 10, 15]"
        :page-size="pagination.pageSize"
        layout="total, sizes, prev, pager, next, jumper"
        :total="pageTotal">
    </el-pagination>
  </div>
</template>
```

2.全屏弹框

```vue
<!--对话框内容展示 ==> 文章信息展示-->
<el-dialog title="修改文章信息" :visible.sync="dialogFormVisible" :fullscreen=true>
  <el-form :model="form">
    
    <el-form-item label="文章标题" :label-width="formLabelWidth">
      <el-input v-model="form.title" autocomplete="off"></el-input>
    </el-form-item>
    
    <el-form-item label="文章类型" :label-width="formLabelWidth">
      <el-select v-model="form.label" placeholder="请选择活动区域">
        <el-option label="Java" value="Java"></el-option>
        <el-option label="随笔" value="suibi"></el-option>
        <el-option label="算法" value="suanfa"></el-option>
        <el-option label="Python" value="Python"></el-option>
        <el-option label="Javascript" value="Javascript"></el-option>
      </el-select>
    </el-form-item>
    
    <el-form-item label="" :label-width="'0px'">
      <h3 style="text-align: center">文章修改</h3>
      
      <mavon-editor
        class="markdown-body"
        v-model="form.context"
        @change="change"
        ref="md"
      />
    
    </el-form-item>
  
  </el-form>
  <div slot="footer" class="dialog-footer">
    <el-button @click="cancel" icon="el-icon-error">取 消</el-button>
    <el-button type="primary" @click="sure" icon="el-icon-success">确 定</el-button>
  </div>
</el-dialog>
```

数据模型

```js
data() {
  return {
    type: 'primary',
    tableData: [], 				// 表格所有内容的数据
    BulkDeletionData: [],   	// 批量删除数据中转站
    multipleSelection: [],  	// 批量删除多选框的选中内容
    TheInformationToDelete: [], // 批量删除中转站
    dialogFormVisible: false,   // 是否展示修改弹层
    dialogTableVisible: false,  // 是否展示批量删除的表格弹层
    visible: false,				// 批量删除的表格弹层是否可见
    codeDataHtml: '',			// html文本
    form: {						// 修改表单的内容
      blogId: '',				// 博客id
      title: '',				// 博客标题
      context: '', 				// markdown语法的文本
      label: '',				// 标签
    },
  }
},
```

相关api `blogApi`

```js
export function updateBlogByLoginUser(blog) {
 return request.put('/blog/update', blog)
}

export function deleteByBlogInLoginUser(blogId) {
 return request({
  method: 'delete',
  url: `/blog/delete/${blogId}`
 })
}
```

相关方法

```js
created() {
  // 组件实例化后发送请求获取表格数据
  getMyBlogByLoginUser().then((res) => {
    this.tableData = res.data.data
  })
},
methods: {
  handleSelectionChange(val) {
    this.multipleSelection = val;
  },
  
  deletes() {
    if (this.BulkDeletionData.length === 0) {
      this.dialogTableVisible = false
      this.$message.error('选择为空,删除失败');
      return
    }
    this.BulkDeletionData = [];
    this.multipleSelection = []
    this.dialogTableVisible = false
    this.sureDel()
    setTimeout(() => {
      window.location.reload()
    }, 1500)
  },
  
  bulkOperations() {
    this.dialogTableVisible = true
    let val = this.multipleSelection
    for (let i = 0; i < val.length; i++) {
      let data = {}
      data.releaseTime = val[i].releaseTime
      data.title = val[i].title
      data.label = val[i].label
      this.BulkDeletionData.push(data)
    }
  },
  
  handleClick(rowDate) {
    this.form = rowDate
    this.markdownChangeHtml()
  },
  goto(rowBody) {
    let blogId = rowBody.blogId
    let routeData = this.$router.resolve({
      path: "/showcase-the-article",
      query: {
        blogId
      }
    });
    window.open(routeData.href, '_blank');
  },
  markdownChangeHtml() {
    // 将markdown转化成html的内容
    this.codeDataHtml = marked(this.form.context)
  },
  change(value, render) {
    //value为编辑器中的实际内容，即markdown的内容，render为被解析成的html的内容
    this.codeDataHtml = render;
  },
  sure() {
    updateBlogByLoginUser(this.form).then((res) => {
      if (res.data.code === 200) {
        this.dialogFormVisible = false
        this.$message({
          message: '修改成功!',
          type: 'success'
        });
      }
    })
  },
  cancel() {
    this.dialogFormVisible = false
    this.$message({
      message: '取消修改',
      type: 'warning'
    });
  },
  Cacneldel() {
    this.dialogTableVisible = false
    this.$message({
      message: '取消删除',
      type: 'warning'
    });
  },
  sureDel(blogId) {
    deleteByBlogInLoginUser(blogId).then((res) => {
      console.log(res.data)
      if (res.data.code === 200) {
        this.$message({
          message: '删除成功',
          type: 'success'
        });
        setTimeout(() => {
          location.reload()
        }, 1000)
      } else {
        this.$message({
          message: '删除失败',
          type: 'error'
        });
      }
    })
  }
}
```

#### 后端代码

`Blog`实体类

```java
@Data
public class Blog implements Serializable {
    /**
     * 博文id
     */
    private Integer blogId;
    /**
     * 用户id
     */
    private Integer uid;
    /**
     * 用户名
     */
    private String username;
    /**
     * 博文标题
     */
    private String title;
    /**
     * 博文内容markdown格式
     */
    private String context;
    /**
     * 博文标签
     */
    private String label;
    /**
     * 博文发布的时间
     */
    private String releaseTime;
    /**
     * 博文访问量 => 因为涉及到域名所有还没有制作
     */
    private Integer watch;
    /**
     * 博文点赞数量
     */
    private Integer star;
    /**
     * 博文收藏量
     */
    private Integer collection;
     /**
     * 是否审核通过 0不通过 1通过 => 后续开发出后台系统时会用到
     */
    // private Integer isPass;
}
```

`BlogController`

```java
@RestController
@RequestMapping("/blog")
@CrossOrigin
public class BlogController {

    @Autowired
    private BlogMapper blogMapper;

    @Autowired
    private BlogService blogService;

    @Autowired
    private UserCommentMapper userCommentMapper;

    @GetMapping("/get-all")
    public Result getAll(@RequestParam(value = "page", defaultValue = "1", required = false) Integer page,
                         @RequestParam(value = "pageSize", defaultValue = "6", required = false) Integer pageSize) {
        // 使用PageHelper设置分页数据
        PageHelper.startPage(page, pageSize);
        // 查询到数据封装到blogPage中
        Page<Blog> blogPage = (Page<Blog>) blogMapper.selectAll();
        // 返回结果和总记录数
        String totalString = Long.toString(blogPage.getTotal());
        return new Result(200, totalString, blogPage.getResult());
    }

    @GetMapping("/get-by-type/{label}")
    public Result getByType(@PathVariable String label) {
        // 根据标签来查询博客所有的信息
        return Result.ok(blogMapper.getBlogByLabel(label));
    }

    @GetMapping("/article/{blogId}")
    public Result getArticleByBlogId(@PathVariable Integer blogId) {
        // 根据博客id来查询博客的所有信息
        Blog articleByBlogId = blogMapper.getArticleByBlogId(blogId);
        return new Result(200, "SUCCESS", articleByBlogId);
    }

    @GetMapping("/me")
    public Result getAllBlogByUid() {
        // 根据token获取uid 查询我的所有博客 => 用于用户个人管理模块的开发
        return Result.ok(blogMapper.getAllBlogByUid(UserHolder.getUid()));
    }

    @GetMapping("/by-user/{id}")
    public Result getBolgDTOByUserId(@PathVariable Integer id) {
        // 查询其他用户的博客信息
        List<UserBlogDTO> info = blogMapper.getBlogByUserId(id);
        System.out.println(info);
        return new Result(200, "SUCCESS", info);
    }

    @GetMapping("/search/{keyWord}")
    public Result SearchByKeyWord(@PathVariable String keyWord) {
        // 根据关键词来查询博客
        System.out.println("keyWord = " + keyWord);
        List<Blog> searchRes = blogMapper.selectByKeyWord(keyWord);
        return new Result(200, "SUCCESS", searchRes);
    }

    @PostMapping("/add")
    public Result addBlogByUid(@RequestBody Blog blog) {
        // 添加博客
        // 从jwt中获取当前登录用户的id
        blog.setUid(UserHolder.getUid());
        // 从jwt中获取当前登录用户的username
        blog.setUsername(UserHolder.getUsername());
        // 设置当前时间
        blog.setReleaseTime(DateFormat.getNowDateFormat());
        // blog.setIsPass(1) 表示直接审核通过 => 在后台中通过(但在开发中...)
        int res = blogMapper.addBlog(blog);
        String msg = res > 0 ? "提交成功" : "提交失败";
        return Result.ok(msg);
    }

    @PutMapping("/update")
    public Result updateBlogByUid(@RequestBody Blog blog) {
        // 用户更新博客
        blog.setUid(UserHolder.getUid());
        // 设置当前时间
        blog.setReleaseTime(DateFormat.getNowDateFormat());
        return Result.update(blogMapper.updateBlogByUid(blog));
    }

    @DeleteMapping("/delete/{blogId}")
    public Result deleteByBlogId(@PathVariable Integer blogId) {
        // 根据博客id和uid来删除博客
        return Result.delete(blogMapper.deleteByBlogIdAndUserId(blogId, UserHolder.getUid()));
    }
}
```

`BlogMapper.xml`

```xml
<mapper namespace="com.tiantian.mapper.BlogMapper">
  <resultMap id="BlogMapperResultMap" type="com.tiantian.pojo.Blog">
    <!--映射关系-->
    <id column="blog_id" property="blogId"/>
    <result column="uid" property="uid"/>
    <result column="username" property="username"/>
    <result column="title" property="title"/>
    <result column="context" property="context"/>
    <result column="label" property="label"/>
    <result column="release_time" property="releaseTime"/>
    <result column="watch" property="watch"/>
    <result column="star" property="star"/>
    <result column="collection" property="collection"/>
  </resultMap>

  <select id="getArticleByBlogId" resultType="com.tiantian.pojo.Blog">
    select *
    from blog
    where blog_id = #{blogId}
  </select>

  <select id="selectAll" resultType="com.tiantian.pojo.Blog">
    select blog_id, username, title, label, release_time
    from blog
  </select>

  <select id="getBlogByUserId" resultType="com.tiantian.dto.UserBlogDTO">
    select blog_id,
           uid,
           title,
           watch,
           star,
           collection,
           release_time
    from blog
    where uid = #{id}
    order by watch desc, star desc, collection desc
  </select>

  <select id="getAllBlogByUid" resultType="com.tiantian.pojo.Blog">
    select *
    from blog
    where uid = #{uid}
  </select>

  <select id="selectByKeyWord" resultType="com.tiantian.pojo.Blog">
    select blog_id,
           uid,
           username,
           title,
           label,
           release_time,
           watch,
           star,
           collection
    from blog
    where title like concat('%', #{keyWord}, '%');
  </select>

  <select id="getBlogByLabel" resultType="com.tiantian.pojo.Blog">
    select blog_id,
           username,
           title,
           label,
           release_time
    from blog
    where label = #{label};
  </select>

  <insert id="addBlog" parameterType=>
        insert into blog
        <trim prefix="(" suffix=")" suffixOverrides=",">
                <if test="blogId != null">blog_id,</if>
                <if test="uid != null">uid,</if>
                <if test="username != null">username,</if>
                <if test="title != null">title,</if>
                <if test="context != null">context,</if>
                <if test="label != null">label,</if>
                <if test="releaseTime != null">release_time,</if>
                <if test="watch != null">watch,</if>
                <if test="star != null">star,</if>
                <if test="collection != null">collection,</if>
        </trim>
        <trim prefix="values (" suffix=")" suffixOverrides=",">
                <if test="blogId != null">#{blogId,jdbcType=INTEGER},</if>
                <if test="uid != null">#{uid,jdbcType=INTEGER},</if>
                <if test="username != null">#{username,jdbcType=VARCHAR},</if>
                <if test="title != null">#{title,jdbcType=VARCHAR},</if>
                <if test="context != null">#{context,jdbcType=VARCHAR},</if>
                <if test="label != null">#{label,jdbcType=VARCHAR},</if>
                <if test="releaseTime != null">#{releaseTime,jdbcType=TIMESTAMP},</if>
                <if test="watch != null">#{watch,jdbcType=INTEGER},</if>
                <if test="star != null">#{star,jdbcType=INTEGER},</if>
                <if test="collection != null">#{collection,jdbcType=INTEGER},</if>
        </trim>
  </insert>


  <update id="updateBlogByUid" parameterType="com.tiantian.pojo.Blog">
    update blog
    <set>
      <if test="title != null and title != ''">
        title = #{title},
      </if>
      <if test="context != null and context != ''">
        context = #{context},
      </if>
      <if test="label != null and label != ''">
        label = #{label},
      </if>
    </set>
    where blog_id = #{blogId} and uid = #{uid}
  </update>

  <delete id="deleteByBlogIdAndUserId">
    delete
    from blog
    where blog_id = #{blogId}
      and uid = #{uid};
  </delete>
    
</mapper>
```

### 3.6.博客展示功能实现

在组件实例化后要获取到当前用户是否已经点赞, 是否已经关注到作者, 是否已经收藏过该文章, 对应展示不同的图标

<img src=".\image\29.博客信息初始化.png" style="zoom:67%;" />

博客渲染

<img src=".\image\30.mavon渲染数据.png" style="zoom:80%;" />

#### 前端代码

博客内容展示的话这里直接复用`mavon-editor`组件即可

```vue
<mavon-editor
  class="markdown-body"
  v-highlight
  ref="md"
  codeStyle="github"
  :ishljs="true"
  v-html="codeDataHtml">
</mavon-editor>
```

组件实例后做的事情

```js
created() {
  // 从路径中获取的博客的blogId再发送请求给后端 后端根据blogId来查询文章
  this.blogId = this.$route.query.blogId
  getBlogByBlogId(this.blogId).then((res) => {
    // 将后端查询到的数据赋值给blogData
    this.blogData = res.data.data
    
    // 若没有查询到数据则跳转到404页面
    if (res.data.data === null) {
      this.$router.replace('/error_404')
    }
    
    // 查询当前用户是否已经关注过作者了并修改isFollow的值 => 后端从jwt中获取到当前登录用户的信息
    isFollow(this.blogData.uid).then((res2) => {
      if (res2.data.data) {
        this.isFollow = true
      }
    })
    this.codeDataMarkDown = res.data.data.context
    this.markdownChangeHtml()
  })
  
  // 查询当前用户是否已经点过赞了
  isDidStar(this.blogId).then((res) => {
    this.isStar = res.data.code === 200;
  })
  
  isComment(this.blogId).then((res) => {
    this.isCollect = res.data.data
  })
  
  // 获取评论信息
  this.getComments()
},
```

#### 后端代码

### 3.7.博客点赞功能实现

#### 前端代码

```html
<!-- 为按钮添加点击事件 isStar标记是否已经点赞 => 已经点赞图标点亮 未点赞图标为灰 -->
<button @click="isStar = !isStar;star()">
    <图标1高亮 v-show="isStar"></图标1>
    <图标2灰色 v-show="!isStar"></图标2>
</button>
```

当vue实例被生成后获取用户是否已经点过赞了

```js
created() {
  // 从路径中获取的博客的blogId(param参数)
  this.blogId = this.$route.query.blogId

  // 查询当前用户是否已经点过赞了
  isDidStar(this.blogId).then((res) => {
    // 若状态码为200则为点过赞 为isStar复制
    this.isStar = res.data.code === 200;
  })
},
```

#### 后端代码

`BlogController`

```java
/**
 * 根据id进行博客点赞
 */
@PutMapping("/like/{BlogId}")
public Result likeBlog(@PathVariable Integer BlogId) {
    return blogService.likeBlog(BlogId);
}
```

`blogMapper.xml`

```xml
  <update id="likeBlogByUid">
    update blog
    set star = star + 1
    where blog_id = #{blogId}
  </update>

  <update id="UnLikeBlogByUid">
    update blog
    set star = star - 1
    where blog_id = #{blogId}
  </update>
```

`BlogServiceImpl`由于业务较为复杂, 这次没有省略业务层

> 使用Redis的zset集合是为了去重, 禁止用户无限制刷赞

```java
@Service
public class BlogServiceImpl implements BlogService {

    @Autowired
    private BlogMapper blogMapper;

    @Autowired
    private StringRedisTemplate stringRedisTemplate;

    @Override
    public Result likeBlog(Integer blogId) {
        // 1.获取登录用户的id
        Integer uid = UserHolder.getUid();
        // 2.先判断当前登录用户是否已经点赞
        String key = BLOG_LIKED_KEY + blogId;
        Double score = stringRedisTemplate.opsForZSet().score(key, uid.toString());
        // 3.如果未点赞 可以点赞
        if (score == null) {
            // 3.1 数据库点赞数数+1
            int res = blogMapper.likeBlogByUid(blogId);
            if (res > 0) {
                // 3.2 点赞成功保存用户到Redis的set集合
                stringRedisTemplate.opsForZSet().add(key, uid.toString(), System.currentTimeMillis());
            }
        } else {
            // 4.如果已经点赞 取消点赞
            // 4.1 数据库点赞数-1
            int res = blogMapper.UnLikeBlogByUid(blogId);
            if (res > 0) {
                // 4.2 取消点赞 把用户从Redis的set集合中移除
                stringRedisTemplate.opsForZSet().remove(key, uid.toString());
            }
        }
        return Result.ok();
    }

    @Override
    public Result isLikeBlog(Integer blogId) {
        // 1.获取登录用户的id
        Integer uid = UserHolder.getUid();
        // 2.先判断当前登录用户是否已经点赞
        String key = BLOG_LIKED_KEY + blogId;
        Double score = stringRedisTemplate.opsForZSet().score(key, uid.toString());
        // 3.不为空 => 已经点赞 => 返回状态码200
        if (score != null) {
            return Result.ok();
        }
        return Result.failure();
    }

}
```



### 3.8.博客评论功能实现

#### 前端代码

[el-drawer组件详细配置](https://element.eleme.cn/#/zh-CN/component/drawer)

当用户点击按钮时`drawer变为true`评论展开如图

<img src=".\image\14.评论展开.png" style="zoom:70%;" />

数据模型

```js
blogId: '',		  // 当前博客id(通过路由进行获取)
content: '',      // 当前登录用户写的评论
UserComments: [], // 存放用户的评论
```

相关代码

```vue
<!--用户评论-->
<el-drawer
  :modal="false"
  size="40%"
  :before-close="handleClose"
  :wrapperClosable="false"
  :title="commentCount"
  :visible.sync="drawer"
  :direction="direction">
  <hr>
  <div style="margin-top: 10px;">
    
    <img width="40" height="40"
         style="float: left;margin-left: 10px;margin-top: 5px;"
         :src="loginUserImg"
         class="rounded" alt="loginUserImg">
    
    <el-input
      type="textarea"
      :autosize="{ minRows: 4, maxRows: 10}"
      placeholder="欢迎您高质量的评论"
      maxlength="1000"
      show-word-limit
      v-model="content">
    </el-input>
  </div>
  <div style="clear: both"></div>
  
  <el-button size="mini" @click="submit">评论</el-button>
  
  <!--遍历用户评论 -->
  <div v-for="UserComment in UserComments" :key="UserComment.id" class="alert alert-secondary"
       role="alert">
    <div>
      <!--用户头像 + 点击用户头像进行跳转-->
      <img width="35" height="35"
           @click="gotoUserInfo(UserComment.uid)"
           :src="UserComment.headurl"
           class="rounded" alt="loginUserImg">
      {{ UserComment.username }}
      <!--评论的时间戳转化为日期(因为后端要根据时间戳进行排序)-->
      <h6 style="float: right;">{{ String(timestampToTime(UserComment.releaseTime)) }}</h6>
    </div>
    <!--清除浮动带来的影响-->
    <div style="clear: both"></div>
    <hr>
    <!--评论的内容-->
    <p>{{ UserComment.content }}</p>
  </div>

</el-drawer>
```

评论模块所有的api

```js
export function getCommentsByBlogId(blogId) {
 return request({
  method: 'GET',
  url: `/blog/comments/${blogId}`
 })
}

export function addComment(data) {
 return request.post('/blog/comments', data)
}

export function isComment(blogId) {
 return request({
  method: 'GET',
  url: `/user/collect/or/not/${blogId}`
 })
}
```

相关方法

```js
// 获取评论信息
getComments() {
  getCommentsByBlogId(this.blogId).then((res) => {
    this.UserComments = res.data.data
  })
},

// 提交用户评论
submit() {
  let content = this.content
  let blogId = this.blogId
  
  let formData = {
    content,
    blogId
  }
  addComment(formData).then((res) => {
    if (res.data.code === 200) {
      this.$message({
        message: '评论成功',
        type: 'success'
      });
      setTimeout(() => {
        // 重新获取评论的信息
        this.getComments();
      }, 300)
      // 清空评论
      this.content = ''
    } else {
      this.$message({
        message: '评论失败',
        type: 'error'
      });
    }
  })
},
// 点击用户头像进行跳转到另外一个用户个人描述页面
gotoUserInfo(uid) {
  console.log(uid)
  let routeData = this.$router.resolve({
    path: "/user",
    // 从路由中传递query参数 user页面则从路径中获取到uid再发送请求查询数据库 详细功请看3.9
    query: {
      uid
    }
  });
  window.open(routeData.href, '_blank');
},
```



#### 后端代码

将用户评论表和用户表两表查询的结果封装到实体类`UserCommentVO`中

```java
@Data
public class UserCommentVO {
    /**
     * 评论唯一id(自增)
     */
    private Integer id;
    /**
     * 被评论的博客id
     */
    private Integer blogId;
    /**
     * 当前用户id
     */
    private Integer uid;
    /**
     * 评论用户的名称
     */
    private String username;
    /**
     * 评论用户的地址
     */
    private String headurl;
    /**
     * 用户评论内容
     */
    private String content;
    /**
     * 用户评论时间(为时间戳)
     */
    private String releaseTime;
}
```

`UserCommentMapper.xml`

getUserCommonsByBlogId方法使用了uid作为用户评论表和用户表的`条件`同时是根据博客id来进行查询,最后再根据时间戳进行排序(前端需要把时间戳转化为日期)

```xml
<mapper namespace="com.tiantian.mapper.UserCommentMapper">
  <resultMap id="UserCommentMapperResultMap" type="com.tiantian.utils.vo.UserCommentVO">
    <!--映射关系-->
    <id column="id" property="id"/>
    <result column="blog_id" property="blogId"/>
    <result column="uid" property="uid"/>
    <result column="username" property="username"/>
    <result column="headurl" property="headurl"/>
    <result column="content" property="content"/>
    <result column="release_time" property="releaseTime"/>
  </resultMap>

  <select id="getUserCommonsByBlogId" resultType="com.tiantian.utils.vo.UserCommentVO">
    select tuc.id, tuc.blog_id, tuc.uid, tuc.content, tuc.release_time, u.username, u.headurl
    from tb_user_comment tuc, user u where tuc.uid = u.uid and tuc.blog_id = #{blogId} order by tuc.release_time desc;
  </select>

  <insert id="addUserComment">
    insert into tb_user_comment
    <trim prefix="(" suffix=")" suffixOverrides=",">
      <if test="blogId != null">blog_id,</if>
      <if test="uid != null">uid,</if>
      <if test="content != null and content != ''">content,</if>
      <if test="releaseTime != ''">release_time</if>
    </trim>
    <trim prefix="values (" suffix=")" suffixOverrides=",">
      <if test="blogId != null">#{blogId},</if>
      <if test="uid != null">#{uid},</if>
      <if test="content != null and content != ''">#{content},</if>
      <if test="releaseTime != ''">#{releaseTime}</if>
    </trim>
  </insert>

  <delete id="deleteUserCommentByCommentIdAndUid">
    delete
    from tb_user_comment
    where id =  #{commentId} and uid = #{uid};
  </delete>
</mapper>
```

`controller层` 由于业务较少这里也直接省略了service层

```java
/**
 * 根据博客id来获取所有的评论信息
 */
@GetMapping("/comments/{blogId}")
public Result getCommentsByBlogId(@PathVariable Integer blogId) {
    return Result.ok(userCommentMapper.getUserCommonsByBlogId(blogId));
}

/**
 * 添加评论
 * @param userCommentVO
 */

@PostMapping("/comments")
public Result addCommentByUid(@RequestBody UserCommentVO userCommentVO) {
    // 从jwt中获取到登录用户 并设置uid
    userCommentVO.setUid(UserHolder.getUid());
    // 设置当前的时间戳
    userCommentVO.setReleaseTime(String.valueOf(System.currentTimeMillis()));
    int count = userCommentMapper.addUserComment(userCommentVO);
    return Result.delete(count);
}
/**
 * 删除评论
 * @param id 当前评论的id
 */
@DeleteMapping("/comments/{id}")
public Result deleteComments(@PathVariable Integer id) {
    return Result.delete(userCommentMapper.deleteUserCommentByCommentIdAndUid(id, UserHolder.getUid()));
}
```

### 3.9.博客收藏功能实现

收藏按钮

<img src=".\image\35.收藏按钮.png" style="zoom:67%;" />

<img src=".\image\34.我的收藏界面.png" style="zoom:80%;" />

#### 前端代码

点击收藏按钮后的逻辑代码

```js
addMyCollect() {
  // 发送请求携带blogId和是否收藏(布尔值)
  addCollect(this.blogId, this.isCollect).then((res) => {
    if (res.data.code === 200) {
      if (this.isCollect) {
        this.blogData.collection++;
      } else {
        this.blogData.collection--;
      }
    } else {
      this.$message.error("收藏失败")
    }
  })
},
```

收藏列表

```vue
<template>
  <div>
    <h3>我的收藏</h3>
    <br>
    <div class="card mb-3" style="cursor: pointer" v-for="mc in myCollects" :key="mc.blogId">
      <div class="card-body">
        <h5 class="card-title" @click="gotoBlog(mc.blogId)">✨{{mc.title}}</h5>
        <el-tag>📰 {{mc.label}}</el-tag>
        <el-tag type="success">❤️ {{mc.star}}</el-tag>
        <el-tag type="info">💫 {{mc.collection}}</el-tag>
        <a @click="gotoUserInfo(mc.uid)" class="card-link mx-3">作者: {{mc.username}}</a>
      </div>
    </div>
  </div>
</template>

<script>
import {getMyCollects} from "@/api/user/collect";

export default {
  name: "MyCollect",
  data() {
    return {
      myCollects:[]
    }
  },
  created() {
    // 组件实例化后发送请求 无需参数(敏感信息直接从jwt获取到uid)
    getMyCollects().then((res) => {
      this.myCollects = res.data.data
    })
  },
  methods:{
    gotoUserInfo(uid){
      // 当用户点击作者用户名后 => 跳转到相应的用户信息界面
      let routeData = this.$router.resolve({
        path: "/user",
        query: {
          uid
        }
      });
      // 另开窗口
      window.open(routeData.href, '_blank');
    },
    // 点击博客标题后 => 跳转到博客的详细界面
    gotoBlog(blogId) {
      let routeData = this.$router.resolve({
        path: "/showcase-the-article",
        query: {
          blogId
        }
      });
      window.open(routeData.href, '_blank');
    }
  }
}
</script>
```

#### 后端代码

```java
@RestController
@RequestMapping("/user")
@CrossOrigin
public class UserCollectController {

    @Autowired
    private UserCollectMapper userCollectMapper;

    @Autowired
    private BlogMapper blogMapper;

    @Autowired
    private StringRedisTemplate stringRedisTemplate;

    @GetMapping("/collect")
    public Result getMyCollect() {
        List<Blog> blogs = userCollectMapper.selectCollectsBlogsByUid(UserHolder.getUid());
        return Result.ok(blogs);
    }

    @PostMapping("/collect")
    @Transactional
    public Result addMyCollect(@RequestBody UserCollect userCollect) {
        // 1.获取登录用户的id
        Integer uid = UserHolder.getUid();
        // 2.先判断当前登录用户是否已经收藏
        Integer blogId = userCollect.getBlogId();
        String key = BLOG_COLLECT_KEY + blogId;
        Double score = stringRedisTemplate.opsForZSet().score(key, uid.toString());
        // 3.如果未收藏 可以收藏
        if (score == null) {
            // 3.1 数据库收藏数+1
            int res = blogMapper.addOneCollection(blogId);
            if (res > 0) {
                // 3.2 收藏成功保存用户到Redis的set集合
                // 3.3 添加收藏关系
                userCollect.setUserId(uid);
                userCollectMapper.insertSelective(userCollect);
                stringRedisTemplate.opsForZSet().add(key, uid.toString(), System.currentTimeMillis());
            }
        } else {
            // 4.如果已经收藏 取消收藏
            // 4.1 数据库收藏数-1
            int res = blogMapper.minusOneCollection(blogId);
            if (res > 0) {
                // 4.2 取消点赞 把用户从Redis的set集合中移除
                // 4.3 删除收藏关系
                userCollectMapper.deleteByCollectIdAndUid(blogId, uid);
                stringRedisTemplate.opsForZSet().remove(key, uid.toString());
            }
        }
        return Result.ok();
    }

    @DeleteMapping("/collect/{collectId}")
    public Result deleteCollect(@PathVariable Integer collectId) {
        return Result.delete(userCollectMapper.deleteByCollectIdAndUid(collectId, UserHolder.getUid()));
    }

    /**
     * 当点进用户界面时判断是否已经关注该用户 <br>
     * 参数: id(当前博客用户的id)
     */
    @GetMapping("/collect/or/not/{blogId}")
    public Result isCollect(@PathVariable Integer blogId) {
        int count = userCollectMapper.selectCollectByBlogIdAndUid(blogId, UserHolder.getUid());
        return Result.ok(count > 0);
    }


}
```

### 3.10.博客分享功能实现

> 这个功能实现起来其实很简单, 直接上代码

```js
//  给按钮添加点击事件
<button class="base-button" @click="copy()">


//  使用计算属性来拼接字符串
computed: {
  shareContent() {
    //  this.blogData.title为当前博客的标题 location.href为当前URL
    return '我分享了一篇文章 "' + this.blogData.title + '" ' + location.href + ' 快来看!'
  }
},
      

// 在copy()这个函数中
copy() {
  // 创建input标签
  let input = document.createElement('input')
  // 将input的值设置为需要复制的内容
  input.value = this.shareContent
  // 添加input标签
  document.body.appendChild(input)
  // 选中input标签
  input.select()
  // 执行复制
  document.execCommand('copy')
  // 成功提示信息
  this.$notify({
     title: '复制成功',
     message: '赶快分享给你的好友吧!',
     type: 'success',
   });
  // 移除input标签
  document.body.removeChild(input)
},
```

### 3.11.定时任务功能实现

> 由于业务简单均为静态定时 这里直接使用了springboot自带的`@EnableScheduling`和`@Scheduled`注解
>
> 基本原理: 每天0点时执行方法changeWord -> 先获取出昨天的句子id -> 将isShow字段设置为(代表已经展示过了) -> 当有人访问WordController时重新查询新的句子(只查询第一条)

`WordMapper.xml`如下

```xml
<select id="getWordAndId" resultMap="WordMapperResultMap">
  select id, word, is_show
  from good_words
  where is_show = 0
  limit 1;
</select>

<update id="updateIsShowByIdInt">
  update good_words
  set is_show = 1
  where id = #{id}
</update>
```

`WordTask`

```java
@Component
@EnableScheduling
public class WordTask {

    @Autowired
    private WordMapper wordMapper;

    @Autowired
    private CacheClient cacheClient;

    @Scheduled(cron = "0 0 0 * * ?") // 每天0点 开始更新每日一句 并做缓存
    public void changeWord(){
        System.err.println("开始执行静态定时任务,时间为: " + LocalDateTime.now());
        // 先获取出当前句子id  再用当前句子的id将字段获取的is_show更新为1
        Word word = wordMapper.getWordAndId();
        wordMapper.updateIsShowByIdInt(word.getId());
        // 将缓存清空
        cacheClient.delete(EVERY_DAY_WORD);
    }
}
```

### 3.12.用户个人信息描述

#### 前端样式

用户个人中心页面(提供修改功能)

<img src=".\image\18.个人页面展示.png" style="zoom:80%;" />

用户修改功能 个人信息支持HTML语法 支持实时预览

<img src=".\image\18.1.用户修改个人信息功能.png" style="zoom:80%;" />

他人页面(提供关注功能)

<img src=".\image\19.他人页面展示.png" style="zoom:80%;" />

#### 前端代码

1.使用了[el-descriptions](https://element.eleme.cn/#/zh-CN/component/descriptions)组件来展示用户的信息与[el-dialog]()弹出框来修改用户信息[el-tooltip]()提示用户谨慎修改, 和Bootstrap的相关样式和图标

> 用户可以写html和内部css 非常具有个性 如果你愿意你甚至可以在里面写一个漂亮的个人介绍 限制1000字

```vue
<template>
  <div>
    <el-descriptions class="margin-top" :title="userinfo.username + '的用户信息'" :column="2" border>
      <template slot="extra">
        <el-tooltip class="item" effect="light" content="一旦修改无法返回" placement="top-start">
          <el-button type="primary" size="small" @click="modifyInfo">操作</el-button>
        </el-tooltip>
      
      </template>
      
      <el-descriptions-item>
        <template slot="label">
          <i class="el-icon-user"></i>
          用户名
        </template>
        {{ userinfo.username }}
      </el-descriptions-item>
      
      <el-descriptions-item>
        <template slot="label">
          <i class="el-icon-message"></i>
          邮箱号
        </template>
        {{ email }}
      </el-descriptions-item>
      
      <el-descriptions-item>
        <template slot="label">
          <i class="el-icon-help"></i>
          身份
        </template>
        {{ userinfo.identity }}
      </el-descriptions-item>
      
      <el-descriptions-item>
        <template slot="label">
          <i class="el-icon-sunrise-1"></i>
          生日
        </template>
        <div class="block">
          <span class="demonstration"></span>
          <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor"
               class="bi bi-calendar-check-fill mb-1" viewBox="0 0 16 16">
            <path
              d="M4 .5a.5.5 0 0 0-1 0V1H2a2 2 0 0 0-2 2v1h16V3a2 2 0 0 0-2-2h-1V.5a.5.5 0 0 0-1 0V1H4V.5zM16 14V5H0v9a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2zm-5.146-5.146-3 3a.5.5 0 0 1-.708 0l-1.5-1.5a.5.5 0 0 1 .708-.708L7.5 10.793l2.646-2.647a.5.5 0 0 1 .708.708z"/>
          </svg>
          {{ userinfo.birthday }}
        </div>
      </el-descriptions-item>
      
      <el-descriptions-item>
        <template slot="label">
          <i class="el-icon-tickets"></i>
          擅长的语言
        </template>
        <div>
          <el-tag size="small" v-for="(item,index) in userinfo.label" :key="index">{{ item }}</el-tag>
        </div>
      </el-descriptions-item>
      
      <el-descriptions-item>
        <template slot="label">
          <i class="el-icon-office-building"></i>
          公司/学校
        </template>
        {{ userinfo.schoolOrCorporation }}
      </el-descriptions-item>
    
    
    </el-descriptions>
    <div class="alert alert-success mt-3" role="alert">
      <h4 class="alert-heading">个人描述</h4>
      <hr>
      <p class="mb-0" v-html="userinfo.description" v-model="userinfo.description"></p>
    </div>
    
    <!--个人文章和学习情况-->
    <div class="alert alert-primary mt-3" role="alert">
      <h4 class="alert-heading">热门文章</h4>
      <hr>
      <!--遍历popularArticles 依次取得blogId uid title watch star collection-->
      <div class="alert alert-light" role="alert" style="zoom: 88%">
        <div class="alert alert-light" v-show="popularArticles.length === 0">
          <el-empty description="暂时莫得"></el-empty>
        </div>
        <ul>
          <li v-for="popular in popularArticles" :key="popular.blogId" @click="goto(popular.blogId)"
              style="cursor:pointer">
            <a href="#" class="alert-link">{{ popular.title }}</a>
            <span style="float: right">
              📅{{ popular.releaseTime }}
              👁️‍🗨️️‍{{ popular.watch }}
              👍{{ popular.star }}
              💎{{ popular.collection }}
            </span>
          </li>
        </ul>
      
      </div>
    </div>
    
    <div class="alert alert-dark" role="alert">
      <h4 class="alert-heading">学习情况</h4>
      <hr>
      <table class="table table-striped table-hover">
        <thead>
        <tr>
          <th scope="col" width="50"></th>
          <th scope="col" width="250">课程名称</th>
          <th scope="col" width="160">学习进度</th>
          <th scope="col" width="250">最近一次学习的时间</th>
          <th scope="col" width="60">查看</th>
        </tr>
        </thead>
        
        <tbody>
        <tr v-for="(cp,index) in classAndProgressList">
          <th scope="row">{{ index + 1 }}</th>
          <td>{{ cp.className }}</td>
          <td>{{ cp.progress }}</td>
          <td>{{ cp.modifyTime }}</td>
          <td><a :href="cp.url" target="_blank">GO</a></td>
        </tr>
        
        </tbody>
      </table>
      <div class="alert alert-light" v-show="classAndProgressList.length === 0">
        <el-empty description="暂时莫得"></el-empty>
      </div>
    </div>
    
    
    <!-- Form -->
    <el-dialog title="TianTianAdmin的用户信息" :visible.sync="dialogFormVisible">
      
      <el-form :model="userinfo">
        
        <el-form-item label="用户名称" :label-width="formLabelWidth">
          <el-input v-model="userinfo.username"
                    maxlength="30"
                    show-word-limit
                    autocomplete="off"></el-input>
        </el-form-item>
        
        <el-form-item label="用户邮箱" :label-width="formLabelWidth">
          <el-input v-model="email" :disabled="true" autocomplete="off"></el-input>
        </el-form-item>
        
        <el-row>
          <el-col :span="10">
            <el-form-item label="身份" :label-width="formLabelWidth">
              <el-select v-model="userinfo.identity" placeholder="请选择身份">
                <el-option label="学生" value="学生"></el-option>
                <el-option label="打工人" value="打工人"></el-option>
                <el-option label="黑社会大哥" value="黑社会大哥"></el-option>
                <el-option label="五星级杀手" value="五星级杀手"></el-option>
              </el-select>
            </el-form-item>
          </el-col>
          
          <el-col :span="14">
            <el-form-item label="生日" :label-width="formLabelWidth">
              <el-date-picker
                v-model="userinfo.birthday"
                type="date"
                placeholder="选择日期">
              </el-date-picker>
            </el-form-item>
          </el-col>
        </el-row>
        
        <el-form-item label="学生/公司" :label-width="formLabelWidth">
          <el-input v-model="userinfo.schoolOrCorporation"
                    maxlength="25"
                    show-word-limit
                    autocomplete="off"></el-input>
        </el-form-item>
        
        
        <!--擅长的语言多选择-->
        <el-form-item label="擅长的语言" :label-width="formLabelWidth">
          <el-tag
            size="small"
            :key="tag"
            v-for="tag in userinfo.label"
            closable
            :disable-transitions="false"
            @close="handleClose(tag)">
            {{ tag }}
          </el-tag>
          
          <el-input
            :disabled="userinfo.label.length === 6"
            class="input-new-tag"
            v-if="inputVisible"
            v-model="inputValue"
            ref="saveTagInput"
            size="small"
            @keyup.enter.native="handleInputConfirm"
            @blur="handleInputConfirm"
          >
          </el-input>
          <el-button v-else class="button-new-tag" size="small" @click="showInput">+ New Tag</el-button>
        </el-form-item>
        <hr>
        <div style="margin-left: 18px;margin-bottom: 20px;">个人描述
          <div style="float: right">
            字体大小
            <el-button size="mini" @click="descriptionSize++">+</el-button>
            <el-button size="mini" @click="descriptionSize--">-</el-button>

          </div>
        </div>
        <el-input
          type="textarea"
          :style="{fontSize: descriptionSize + 'px'}"
          :autosize="{ minRows: 8, maxRows: 20}"
          placeholder="请输入个人描述"
          maxlength="1500"
          show-word-limit
          v-model="userinfo.description">
        </el-input>
      
      
      </el-form>
      <div slot="footer" class="dialog-footer">
        <button type="button" class="btn btn-secondary mx-1" @click="cancel">取 消</button>
        <button type="button" class="btn btn-outline-info mx-2" @click="view">预 览</button>
        <button type="button" class="btn btn-primary me-1" @click="sure">确 定</button>
      </div>
    </el-dialog>
  
  </div>
</template>

<script>
import axios from "axios";
import {getBaseUserInfoByUid, UpdateUserInfoByUid} from '@/api/user/user'
import {getCourseByUid} from "@/api/course/course";

export default {
  name: "SpaceInfo",
  data() {
    return {
      uid: '',
      email: '',
      userinfo: {},
      popularArticles: [],
      classAndProgressList: [],
      dialogFormVisible: false,
      formLabelWidth: '100px',
      descriptionSize: 18,
      
      inputVisible: false,
      inputValue: ''
    }
  },
  created() {
    let userInfo = JSON.parse(localStorage.getItem("userInfo"));
    this.uid = userInfo.uid
    this.email = userInfo.email
    
    // 获取基础用户信息
    this.getUserInfo()
    
    // 根据用户id来(从store中) =>  获取 标题 观看人数 点赞人数 时间
    axios.get(`http://localhost/blog/by-user/${this.uid}`).then((res) => {
      console.log(res.data)
      this.popularArticles = res.data.data
    }, (error) => {
      console.log(error.message)
    })
    
    // 根据用户id来获取课程的信息
    getCourseByUid(this.uid).then(res => {
      this.classAndProgressList = res.data.data
    }, err => {
      console.log(err.message)
    })
  },
  
  methods: {
    modifyInfo() {
      this.dialogFormVisible = true
    },
    getUserInfo() {
      // 获取基础用户信息
      getBaseUserInfoByUid(this.uid).then((res) => {
        this.userinfo = res.data.data
      })
    },
    
    sure() {
      this.dialogFormVisible = false
      UpdateUserInfoByUid(this.userinfo).then((res) => {
        if (res.data.code === 200) {
          this.$message({
            message: '修改成功',
            type: 'success'
          });
        } else {
          this.$message({
            message: '修改失败',
            type: 'error'
          });
        }
      })
      
      this.dataReload()
      
    },
    view() {
      this.dialogFormVisible = false
      this.$notify({
        title: '提示',
        message: '预览中,点击确定即可提交',
        duration: 0
      });
    },
    
    cancel() {
      this.dialogFormVisible = false
      this.$message({
        message: '取消修改',
        type: 'warning'
      });
      this.dataReload()
    },
    
    goto(blogId) {
      let routeData = this.$router.resolve({
        path: "/showcase-the-article",
        query: {
          blogId
        }
      });
      window.open(routeData.href, '_blank');
    },
    
    // 标签的添加
    handleClose(tag) {
      this.userinfo.label.splice(this.userinfo.label.indexOf(tag), 1);
    },
    
    showInput() {
      this.inputVisible = true;
      this.$nextTick(_ => {
        this.$refs.saveTagInput.$refs.input.focus();
      });
    },
    
    dataReload() {
      // 重新获取数据
      setTimeout(() => {
        window.location.reload()
      }, 200)
    },
    
    handleInputConfirm() {
      let inputValue = this.inputValue;
      if (inputValue) {
        this.userinfo.label.push(inputValue);
      }
      
      if (inputValue.length >= 10) {
        this.$notify({
          title: '警告',
          message: '标签长度不超过10',
          type: 'warning'
        });
        this.userinfo.label.pop()
        return
      }
      // 限制用户添加标签的个数
      if (this.userinfo.label.length >= 6) {
        this.$notify({
          title: '警告',
          message: '最多可以添加6个标签',
          type: 'warning'
        });
      }
      this.inputVisible = false;
      this.inputValue = '';
    },
  },
  
}

</script>

<style lang="css">

::-webkit-scrollbar {
  width: 6px;
}

/*定义滚动条轨道 内阴影+圆角*/
::-webkit-scrollbar-track {
  border-radius: 10px;
  background-color: rgba(0, 0, 0, 0.1);
}

/*定义滑块 内阴影+圆角*/
::-webkit-scrollbar-thumb {
  border-radius: 10px;
  -webkit-box-shadow: inset 0 0 6px rgba(0, 0, 0, .3);
  background-color: rgba(0, 0, 0, 0.1);
}

.el-tag + .el-tag {
  margin-left: 10px;
}

.button-new-tag {
  margin-left: 10px;
  height: 32px;
  line-height: 30px;
  padding-top: 0;
  padding-bottom: 0;
}

.input-new-tag {
  width: 90px;
  margin-left: 10px;
  vertical-align: bottom;
}
</style>
```

相关api

```js
export function getCourseByUid(uid) {
	return request({
		method: 'GET',
		url: `course/user/${uid}`,
	})
}

export function getBaseUserInfoByUid(uid) {
	return request({
		method: 'GET',
		url: `/users/base/${uid}`,
	})
}

export function UpdateUserInfoByUid(baseUserInfo) {
	return request.put('/users/base/update', baseUserInfo)
}

```

#### 后端代码

`实体类BaseUserInfo`

```java
@Data
public class BaseUserInfo implements Serializable {
    private static final long serialVersionUID = 1L;
    /**
     * 用户id
     */
    private Integer uid;
    /**
     * 用户身份
     */
    private String identity;
    /**
     * 用户性别
     */
    private Integer gender;
    /**
     * 用户名称
     */
    private String username;
    /**
     * 用户生日
     */
    private String birthday;
    /**
     * 用户删除的语言标签
     */
    private List<String> label;
    /**
     * 用户个人描述
     */
    private String description;
    /**
     * 用户填写的公司或者名称
     */
    private String schoolOrCorporation;
}
```

`UserController`

```java
@Autowired
private UserService userService;

@GetMapping("/base/{uid}")
public Result getBaseUserInfoByUid(@PathVariable Integer uid) {
    BaseUserInfo baseUserInfo = userService.getBaseUserInfoByUid(uid);
    return Result.ok(baseUserInfo);
}

@PutMapping("/base/update")
public Result updateBaseUserInfoByUid(@RequestBody BaseUserInfo baseUserInfo) {
    int i = userService.updateBaseUserInfoByUid(baseUserInfo);
    if (i > 0) {
        return Result.ok();
    }
    return Result.failure();
}


```

`CourseController`

```java
@Autowired
private CourseService courseService;
@GetMapping("/user/{uid}")
public Result getUserClassAndProgress(@PathVariable Integer uid) {
    Integer uid1 = UserHolder.getUid();
    List<UserClassAndProgressVO> courseList = courseService.selectUserClassAndProgress(uid1);
    return new Result(200, "SUCCESS", courseList);
}
```

`相关Service`

```java
@Override
public BaseUserInfo getBaseUserInfoByUid(Integer uid) {
    return baseUserInfoMapper.selectByUid(uid);
}
```



注: 这里前端传过来的用户信息中的`标签`是一个集合且实体类中的label类型是`List<String>`，而集合是不能直接存储在数据库中的，解决方案如下:

方案一:

将集合转为字符串存储在数据库 读取时将"[]"去除并按照", "进行切分得到一个数组直接返回给前端，这样的作法的缺点是每次存集合都要进行重复的操作代码代码的冗余

方案二:

实现mytais提供的类型转换接口`TypeHandler`，自定义类型转换器来的更加优雅，的实现逻辑也是如上思路

这样做的优点是可以直接接受到前端传递过来的集合并直接存储，读取时返回给前端的也是集合(前端叫数组)

代码如下(直接复制粘贴即可)

```java
/**
 * 类型转换器，用于数据库的varchar和Java中List<String>类型的相互转换
 */
@MappedJdbcTypes(JdbcType.VARCHAR)
@MappedTypes(List.class)
public class ListToVarcharTypeHandler implements TypeHandler<List<String>> {
    @Override
    public void setParameter(PreparedStatement preparedStatement, int i, List<String> strings, JdbcType jdbcType) throws SQLException {
        // 遍历List类型的入参，拼装为String类型，使用Statement对象插入数据库
        StringBuffer sb = new StringBuffer();
        for (int j = 0; j < strings.size(); j++) {
            if (j == strings.size() - 1) {
                sb.append(strings.get(j));
            } else {
                sb.append(strings.get(j)).append(",");
            }
        }
        preparedStatement.setString(i, sb.toString());
    }

    @Override
    public List<String> getResult(ResultSet resultSet, String s) throws SQLException {
        // 获取String类型的结果，使用","分割为List后返回
        String resultString = resultSet.getString(s);
        if (StringUtils.isNotEmpty(resultString)) {
            return Arrays.asList(resultString.split(","));
        }
        return null;
    }

    @Override
    public List<String> getResult(ResultSet resultSet, int i) throws SQLException {
        // 获取String类型的结果，使用","分割为List后返回
        String resultString = resultSet.getString(i);
        if (StringUtils.isNotEmpty(resultString)) {
            return Arrays.asList(resultString.split(","));
        }
        return null;
    }

    @Override
    public List<String> getResult(CallableStatement callableStatement, int i) throws SQLException {
        // 获取String类型的结果，使用","分割为List后返回
        String resultString = callableStatement.getString(i);
        if (StringUtils.isNotEmpty(resultString)) {
            return Arrays.asList(resultString.split(","));
        }
        return null;
    }
}
```

`相关mapper.xml`

注意在`resultMap`中的label要加上上面自定的处理器`typeHandler="com.xxx.handler.ListToVarcharTypeHandler"`

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.tiantian.mapper.BaseUserInfoMapper">

    <resultMap id="BaseResultMap" type="com.tiantian.pojo.BaseUserInfo">
            <id property="uid" column="uid"/>
            <result property="identity" column="identity"/>
            <result property="gender" column="gender"/>
            <result property="username" column="username"/>
            <result property="birthday" column="birthday"/>
            <result property="label" column="label" typeHandler="com.tiantian.handler.ListToVarcharTypeHandler"/>
            <result property="description" column="description"/>
            <result property="schoolOrCorporation" column="school_or_corporation"/>
    </resultMap>

    <sql id="Base_Column_List">
      uid,gender
      ,identity,username,
        birthday,label,description,
        school_or_corporation
    </sql>

    <select id="selectByUid" resultMap="BaseResultMap">
        select
        <include refid="Base_Column_List" />
        from base_user_info
        where  uid = #{uid};
    </select>
  
    <insert id="insert" keyColumn="uid" keyProperty="uid" parameterType="com.tiantian.pojo.BaseUserInfo">
      insert into base_user_info
      <trim prefix="(" suffix=")" suffixOverrides=",">
        <if test="uid != null">uid,</if>
        <if test="identity != null and identity != ''">identity,</if>
        <if test="gender != null and gender != ''">gender,</if>
        <if test="username != null and username != ''">username,</if>
        <if test="birthday != null and birthday != ''">birthday,</if>
        <if test="label != null and label != '' ">label,</if>
        <if test="description != null and description != ''">description,</if>
        <if test="schoolOrCorporation != null and schoolOrCorporation != ''">school_or_corporation,</if>
      </trim>
      <trim prefix="values (" suffix=")" suffixOverrides=",">
        <if test="uid != null">#{uid},</if>
        <if test="identity != null and identity != ''">#{identity},</if>
        <if test="gender != null and gender != ''">#{gender},</if>
        <if test="username != null and username != ''">#{username},</if>
        <if test="birthday != null and birthday != ''">#{birthday},</if>
        <if test="label != null and label != ''">#{label,typeHandler=com.tiantian.handler.ListToVarcharTypeHandler},
        </if>
        <if test="description != null and description != ''">#{description},</if>
        <if test="schoolOrCorporation != null and schoolOrCorporation != ''">#{schoolOrCorporation},</if>
      </trim>
    </insert>
  
    <update id="updateByUid" parameterType="com.tiantian.pojo.BaseUserInfo">
      update base_user_info
      <set>
        <if test="identity != null and  identity != '' ">
          identity = #{identity},
          </if>

        <if test="gender != null and  gender != '' ">
          gender = #{gender},
        </if>
          
        <if test="username !=null and  username != '' ">
          username = #{username},
          </if>
          
        <if test="birthday != null and  birthday != ''">
          birthday = #{birthday},
          </if>
          
        <if test="label != null and  label != ''">
          label = #{label,typeHandler=com.tiantian.handler.ListToVarcharTypeHandler},
          </if>
          
        <if test="description != null and  description != ''">
          description = #{description},
          </if>
          
        <if test="schoolOrCorporation != null and schoolOrCorporation != ''">
          school_or_corporation = #{schoolOrCorporation}
        </if>

      </set>
      where uid = #{uid}
    </update>
</mapper>
```

### 3.13.修改密码功能实现

<img src=".\image\37.用户验证界面.png" style="zoom:80%;" />

缓存(key为uid, 值为验证码, 并设置五分钟后过期)

<img src=".\image\39.缓存.png" style="zoom:80%;" />

收到验证码

<img src=".\image\40.收到验证码.png" style="zoom:80%;" />

验证成功后直接修改

<img src=".\image\38.用户修改密码.png" style="zoom:80%;" />

#### 前端代码

这里使用了[el-steps步骤条](https://element.eleme.cn/#/zh-CN/component/steps)组件

```vue
<template>
  <div>
    <div style="margin: 20px auto">
      <el-steps :active="index"
                finish-status="success"
                simple
                style="margin-top: 20px"
                direction="vertical">
        <el-step title="通过邮箱验证" icon="el-icon-s-comment"></el-step>
        <el-step title="修改密码" icon="el-icon-refresh-right"></el-step>
      </el-steps>
      
      
      <div v-show="index === 1">
        <h4>请输入您注册时使用的邮箱</h4>
        <el-input placeholder="请输入您的邮箱"
                  v-model="email"
                  @keyup.enter.native="getVerify">
          <template slot="append">
            <el-button
              :disabled="disabled"
              style="float: right"
              @click="getVerify">
              {{ !showTime ? "发送" : count }}
            </el-button>
          </template>
        </el-input>
        <br>
        <br>
        
        <el-input placeholder="请输入您收到的6位验证码"
                  v-model="verifyCode"
                  @keyup.enter.native="VerifyVerificationCode">
          <template slot="append">
            <el-button
              :disabled="!disabled"
              style="float: right"
              @click="VerifyVerificationCode">
              立即验证
            </el-button>
          </template>
        </el-input>
        
        
        <el-col v-show="showSuccess">
          <el-result icon="success" title="验证成功" subTitle="请点击下一步进行操作">
          </el-result>
        </el-col>
        
        <el-col v-show="showError">
          <el-result icon="error" title="验证失败" subTitle="验证码错误">
          </el-result>
        </el-col>
      
      </div>
      
      
      <el-form
        v-show="index === 2"
        style="margin: 50px auto; width: 500px;"
        :model="ruleForm"
        status-icon
        :rules="rules"
        ref="ruleForm"
        label-width="100px"
        class="demo-ruleForm">
        
        <el-form-item label="密码" prop="pass">
          <el-input type="password" v-model="ruleForm.pass" autocomplete="off"></el-input>
        </el-form-item>
        
        <el-form-item label="确认密码" prop="checkPass">
          <el-input type="password" v-model="ruleForm.checkPass" autocomplete="off"></el-input>
        </el-form-item>
        
        
        <el-form-item>
          <el-button type="primary" @click="submitForm">提交</el-button>
          <el-button @click="resetForm()">重置</el-button>
        </el-form-item>
      </el-form>
      
      <button v-show="showNext"
              @click="nextStep"
              class="btn btn-primary"
              style="float: right;margin-top: 50px">下一步
      </button>
    </div>
  </div>
</template>

<script>
import {userChangePWDByEmail, isCode} from '@/api/user/user'

export default {
  name: "ChangePwd",
  data() {
    // 一系列表单认证
    this.validatePass = (rule, value, callback) => {
      if (value === '') {
        callback(new Error('请输入密码'));
      } else {
        if (value.length < 8) {
          callback(new Error('密码必须大于8位'));
        }
        if (this.ruleForm.checkPass !== '') {
          this.$refs.ruleForm.validateField('checkPass');
        }
        callback();
      }
    };
    this.validatePass2 = (rule, value, callback) => {
      if (value === '') {
        callback(new Error('请再次输入密码'));
      } else if (value !== this.ruleForm.pass) {
        callback(new Error('两次输入密码不一致!'));
      } else {
        callback();
      }
    };
    return {
      // 数据模型
      index: 1, // 全局索引
      validatePass: '', // 第一次输入的密码
      validatePass2: '',// 第二次输入的密码
      showNext: false,
      
      showTime: false,
      count: "0",  // 初始化次数
      disabled: false, // 按钮是否禁用
      timer: null,  // 计数器
      showSuccess: false,  // 展示成功的结果
      showError: false,	   // 展示失败的结果
      
      email: '', // 用户输入的邮箱
      verifyCode: '', // 验证码的内容
      
      ruleForm: {
        pass: '',
        checkPass: '',
      },
      rules: {
        pass: [
          {validator: this.validatePass, trigger: 'blur'}
        ],
        checkPass: [
          {validator: this.validatePass2, trigger: 'blur'}
        ]
      }
    };
  },
  
  methods: {
    nextStep() {
      // 点击按钮后执行 index++
      this.index++;
      if (this.index === 2) {
        this.showNext = false;
      }
    },
    // 重置表单
    resetForm() {
      this.ruleForm.pass = ''
      this.ruleForm.checkPass = ''
    },
    // 提交表单
    submitForm() {
      if (this.ruleForm.pass !== this.ruleForm.checkPass) {
        this.$message({
          showClose: true,
          message: '两次密码输入不一致',
          type: 'error'
        });
        this.resetForm()
      } else {
        changePassword(this.ruleForm.checkPass).then((res) => {
          if (res.data.code === 200) {
            this.$message({
              showClose: true,
              message: '修改成功',
              type: 'success'
            });
          } else {
            this.$message({
              showClose: true,
              message: '修改失败, 未知原因',
              type: 'error'
            });
          }
        })

        this.$router.push('/user-space/space-info')
      }
    },
    
    getVerify() {
      // 验证邮箱是否符合规则
      if (!/^([a-zA-Z\d][\w-]{2,})@(\w{2,})\.([a-z]{2,})(\.[a-z]{2,})?$/.test(this.email)) {
        this.$message.error("请填写正确的邮箱号");
      } else {
        // 开启定时器
        this.showTime = true;
        // 发送验证码的按钮失效
        this.disabled = true;
        // 调用后端接口发送验证码
        userChangePWDByEmail(this.email).then((res) => {
          if (res.data.code === 200) {
            this.$notify({
              title: 'SUCCESS',
              message: '发送成功,请注意接收' +
                '\r\n5分钟内有效,请勿泄露或转发他人',
              type: 'success'
            });
            // 显示倒计时
            this.showTime = true
            // 更改倒计时时间
            const TIME_COUNT = 60 
            if (!this.timer) {
              this.count = TIME_COUNT
              this.show = false
              this.timer = setInterval(() => {
                if (this.count > 0 && this.count <= TIME_COUNT) {
                  this.count--
                } else {
                  this.show = true
                  // 清除定时器
                  clearInterval(this.timer)
                  // 关闭倒计时
                  this.showTime = true
                  this.timer = null
                }
              }, 1000);
            }
          } else {
            // 提示错误信息
            this.$message({
              showClose: true,
              message: '发送失败',
              type: 'error'
            });
          }
        })
      }
    },
    // 验证码相关逻辑
    VerifyVerificationCode() {
      if (this.verifyCode === '') {
        this.$message({
          showClose: true,
          message: '验证码不能为空',
          type: 'error'
        });
      }
      
      if (this.verifyCode.length > 6) {
        this.$message({
          showClose: true,
          message: '验证码不符合规范',
          type: 'error'
        });
      }
      
      isCode(this.verifyCode).then((res) => {
        if (res.data.code === 200) {
          this.showSuccess = true;
          this.showNext = true;
        } else {
          this.$message({
            showClose: true,
            message: '验证码错误',
            type: 'error'
          });
        }
      })
      
      
    }
  },
}
</script>

<style scoped>

</style>
```

#### 后端代码

> 发送验证码这里使用了spring-boot-starter-mail操作qq邮箱来发送验证码

`Springboot发送qq邮件模板`如下 直接复制粘贴即可

1.接口

```java
public interface SendMailService {

    /**
     * 简单文本邮件
     * @param mailRequest
     * @return
     */
    void sendSimpleMail(MailRequest mailRequest);


    /**
     * Html格式邮件,可带附件
     * @param mailRequest
     * @return
     */
    void sendHtmlMail(MailRequest mailRequest);
}
```

2.实现类

```java
@Service
@Slf4j
public class SendMailServiceImpl implements SendMailService {

    // 注入邮件工具类
    @Autowired
    private JavaMailSender javaMailSender;

    @Value("${spring.mail.username}")
    private String sendMailer;


    public void checkMail(MailRequest mailRequest) {
        Assert.notNull(mailRequest,"邮件请求不能为空");
        Assert.notNull(mailRequest.getSendTo(), "邮件收件人不能为空");
        Assert.notNull(mailRequest.getSubject(), "邮件主题不能为空");
        Assert.notNull(mailRequest.getText(), "邮件收件人不能为空");
    }

    @Override
    public void sendSimpleMail(MailRequest mailRequest) {
        SimpleMailMessage message = new SimpleMailMessage();
        checkMail(mailRequest);
        // 邮件发件人
        message.setFrom(sendMailer);
        // 邮件收件人 1或多个
        message.setTo(mailRequest.getSendTo().split(","));
        // 邮件主题
        message.setSubject(mailRequest.getSubject());
        // 邮件内容
        message.setText(mailRequest.getText());
        // 邮件发送时间
        message.setSentDate(new Date());

        javaMailSender.send(message);
        log.info("发送邮件成功:{}->{}",sendMailer,mailRequest.getSendTo());
    }



    @Override
    public void sendHtmlMail(MailRequest mailRequest) {
        MimeMessage message = javaMailSender.createMimeMessage();
        checkMail(mailRequest);
        try {
            MimeMessageHelper helper = new MimeMessageHelper(message,true);
            // 邮件发件人
            helper.setFrom(sendMailer);
            // 邮件收件人 1或多个
            helper.setTo(mailRequest.getSendTo().split(","));
            // 邮件主题
            helper.setSubject(mailRequest.getSubject());
            // 邮件内容
            helper.setText(mailRequest.getText(),true);
            // 邮件发送时间
            helper.setSentDate(new Date());

            String filePath = mailRequest.getFilePath();
            if (StringUtils.hasText(filePath)) {
                FileSystemResource file = new FileSystemResource(new File(filePath));
                String fileName = filePath.substring(filePath.lastIndexOf(File.separator));
                helper.addAttachment(fileName,file);
            }
            javaMailSender.send(message);
            log.info("发送邮件成功:{}->{}",sendMailer,mailRequest.getSendTo());
        } catch (MessagingException e) {
            log.error("发送邮件时发生异常！",e);
        }
    }
}
```

注意要在qq邮箱中开启pop3功能并修改yml配置文件

设置 -> 账号 -> 开启POP3/IMAP

开启后获取密钥 填写到application.yml文件中

<img src=".\image\33.开启pop3功能.png" style="zoom:80%;" />

```yml
  host: smtp.qq.com
  username: 自己的qq邮箱
  password: 申请到的密钥
  default-encoding: utf-8
  properties:
    mail:
      smtp:
        auth: true
        starttls:
          enable: true
          required: true
```

在controller中调用

```java
@RestController
@RequestMapping("/users")
@CrossOrigin
@SuppressWarnings("all")
public class UserController {

    @Autowired
    private UserService userService;

    @Autowired
    private SendMailService sendMailService;

    @Autowired
    private RedisTemplate redisTemplate;

    @PostMapping("/simple/{email}")
    @SaCheckLogin
    public Result SendVerificationCodeMessage(@PathVariable String email) {
        // 从token中获取uid
        Integer uid = UserHolder.getUid();
        // 生成6位随机验证码
        String verification6Code = RandomUtil.randomString(6);

        MailRequest mailRequest = new MailRequest();
        mailRequest.setSubject("应科博客");
        mailRequest.setSendTo(email);
        // 存入Redis设置5分钟之后过期
        String key = USER_CHANGE_PWD + uid;
        redisTemplate.opsForValue().set(key, verification6Code, 5, TimeUnit.MINUTES);

        mailRequest.setText("【应科博客】，尊敬的TianTianStudy用户，您正在修改密码，您的你的验证码为: " + verification6Code + "，该验证码5分钟内有效，请勿泄露他人。");
        mailRequest.setFrom("1979214069@qq.com" + "(应科博客)");
        sendMailService.sendSimpleMail(mailRequest);
        return Result.ok();
    }

    @PostMapping("/verification/{code}")
    public Result verification(@PathVariable("code") String userInputCode) {
        String key = USER_CHANGE_PWD + UserHolder.getUid();
        String codeCache = String.valueOf(redisTemplate.opsForValue().get(key));

        // 若在缓存中查询失败则直接返回错误状态码
        if (codeCache == null || codeCache == "") {
            return Result.failure();
        }

        // 判断用户输入的验证码和Redis中是否相同
        if (StrUtil.equals(codeCache,userInputCode)) {
            // 验证成功后直接删除缓存 并返回状态码200给前端
            redisTemplate.delete(key);
            return Result.ok();
        } else {
            return Result.failure();
        }
    }
}

```

`修改密码接口`

```java
@PutMapping("/update/pwd")
public Result updatePasswrod(String password) {
    // 加密存储
    String encryptionPwd = SaSecureUtil.aesEncrypt(passwordKey, password);
    return Result.update(userService.updatePasswordByUid(encryptionPwd, UserHolder.getUid()));
}
```

`UserMapper.xml`

```xml
<update id="updatePasswordByUid">
  update user set password = #{password} where uid = #{uid}
</update>
```

### 3.14.数据可视化

> 由于数据量太少且后台还在开发中, 所以这里的数据均为写死的数据(无后端), 先提前做好组件, 方便后续拓展

#### 前端样式

<img src=".\image\20.数据可视化之学习.png" style="zoom:80%;" />

#### 前端代码

日历图使用了[calendar-heatmap](https://cloud.tencent.com/developer/article/1695558)组件, 剩余的均为[ECharts](https://echarts.apache.org/zh/index.html)相关组件 (均可直接复用)

1.词云图组件

```vue
<template>
  <div>
    <br>
    <div style="height:400px;width: auto;" id="MyWordCloud"></div>
  </div>
</template>


<script>
import "echarts-wordcloud/dist/echarts-wordcloud";
import "echarts-wordcloud/dist/echarts-wordcloud.min";
import {getCourseWordCountByUid} from '@/api/course/course'

export default {
  name: "MyWordCloud",
  data() {
    return {
      uid: '',
      keyWordData: [],
      // 若没有数据则显示这个
      defaultData: [{'name': '莫得数据', 'value': 666666}]
    };
  },
  mounted() {
    let that = this
    // 延时获取并渲染数据
    setTimeout(() => {
      that.showEeharts();
    }, 1500)
  },
  
  created() {
    // 从localStorage从获取到用户的信息并转化为对象
    let userInfo = JSON.parse(localStorage.getItem("userInfo"));
    this.uid = userInfo.uid
    // 发送请求给获取数据
    getCourseWordCountByUid(this.uid).then(res => {
      this.keyWordData = res.data.data
    })
  },
  
  methods: {
    showEeharts() {
      this.$echarts.init(document.getElementById('MyWordCloud')).setOption({
        title: {
          text: '学习关键词分析',//标题
          x: 'top',
          textStyle: {
            fontSize: 30
          }
        },
        backgroundColor: '#F7F7F7',
        tooltip: {
          show: true
        },
        series: [{
          name: '学习词频统计',//数据提示窗标题
          type: 'wordCloud',
          shape: 'circle',
          sizeRange: [30, 60],//画布范围，如果设置太大会出现少词（溢出屏幕）
          rotationRange: [-45, 90],//数据翻转范围
          textPadding: 0,
          layoutAnimation: true,
          drawOutOfBound: true,
          autoSize: {
            enable: true,
            minSize: 6
          },
          textStyle: {
            fontFamily: 'sans-serif',
            fontWeight: 'bold',
            
            color: function () {
              return 'rgb(' + [
                Math.round(Math.random() * 160),
                Math.round(Math.random() * 160),
                Math.round(Math.random() * 160)
              ].join(',') + ')';
            },
            
            emphasis: {
              shadowBlur: 10,
              shadowColor: '#333'
            }
          },
          data: this.keyWordData || this.defaultData
        }]
      });
    },
  },
};
</script>
```

2.饼图组件

```vue
<template>
  <div id="MyPieSimple" style="float: right;width: 600px;height: 500px;"></div>
</template>

<script>
export default {
  name: "PieSimple",
  data(){
    return {
      // 数据模型
      dataList:[]
    }
  },
  mounted() {
    this.initPieSimple()
  },
  methods:{
    initPieSimple(){
      this.$echarts.init(document.getElementById('MyPieSimple')).setOption({
        title: {
          text: 'Referer of a Website',
          subtext: 'Fake Data',
          left: 'center'
        },
        tooltip: {
          trigger: 'item',
          backgroundColor: 'rgba(255,255,255,0.8)',
        },
        legend: {
          orient: 'vertical',
          left: 'left'
        },
        series: [
          {
            name: 'Access From',
            type: 'pie',
            radius: '50%',
            data: [
              // 暂时为模拟的数据
              { value: 1048, name: 'Search Engine' },
              { value: 735, name: 'Direct' },
              { value: 580, name: 'Email' },
              { value: 484, name: 'Union Ads' },
              { value: 300, name: 'Video Ads' }
            ],
            emphasis: {
              itemStyle: {
                shadowBlur: 10,
                shadowOffsetX: 0,
                shadowColor: 'rgba(0, 0, 0, 0.5)'
              }
            }
          }
        ]
      })
    }
  }
}
</script>

<style scoped>

</style>
```

2.日历图组件 后续可以拓展为学习签到图

```vue
<template>
  <div style="padding: 30px;" class="bg-light">
    <calendar-heatmap
      end-date="2023-04-02"
      tooltip-unit="贡献"
      :range-color="['#ebedf0', '#9be9a8', '#40c463', '#30a14e', '#216e39']"
      :values="timeValue"/>
  </div>
</template>
<script>
import {CalendarHeatmap} from "vue-calendar-heatmap";

export default {
  data() {
    return {
      // 模拟数据 值为日期 键为贡献值
      timeValue: [
        {date: "2023-04-01", count: 12},
        {date: "2023-04-02", count: 6},
        {date: "2023-03-31", count: 6},
        {date: "2023-03-30", count: 8},
        {date: "2023-03-30", count: 2},
        {date: "2023-03-29", count: 1},
        {date: "2023-03-28", count: 15},
        {date: "2023-03-27", count: 1},
        {date: "2023-03-26", count: 6},
        {date: "2023-03-25", count: 2},
        {date: "2023-03-24", count: 10},
        {date: "2023-03-23", count: 2},
        {date: "2023-03-22", count: 3},
        {date: "2023-03-21", count: 2},
      ],
    };
  },
  components: {
    CalendarHeatmap,
  },
};
</script>
<style lang="scss" scoped>
</style>
```


最后感谢你能看到这里
如果你发现其中的问题 可以直接在gitee中修改https://gitee.com/tiantian17/yingke-blog